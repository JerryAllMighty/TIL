[서두]
- JVM의 이식성에 관하여 글을 정리했는데 공유하려 한다.

[내용]
JVM이 나오게 된 배경
1990년대 초, 자바는 가전/임베디드용으로 시작했다가 인터넷·웹 붐과 함께 “한 번 작성하면 어디서나 실행”되는 언어를 목표로 발전했습니다.

당시 C/C++은 플랫폼마다 다른 컴파일러·바이너리가 필요해 이식성이 낮고, 메모리 관리도 개발자 책임이라 실수가 많았습니다.

JVM이 해결하려던 핵심 문제
JVM 위에서 바이트코드를 실행하게 해 OS·CPU에 상관없이 동일한 프로그램을 돌릴 수 있도록 하여 플랫폼 의존성을 크게 줄였습니다.

가비지 컬렉션과 타입 검사, 바이트코드 검증 등을 통해 포인터 버그, 메모리 오염 같은 전통적인 C/C++ 문제를 완화하고, 보안성을 강화하려 했습니다.

JVM의 한계와 트레이드오프
가상 머신 위에서 돌아가고 GC·JIT 최적화가 필요하다 보니, 네이티브 코드에 비해 시작 속도와 메모리 사용량에서 불리한 경우가 있습니다.

완전한 플랫폼 독립성도 한계가 있어서, 네이티브 라이브러리나 OS 기능을 쓰면 여전히 환경 차이에 따른 이슈가 발생합니다.

이식성
이식성의 실제 범위는 어떻게 되나?
바이트코드만 같으면 된다는 말은 이론상이고, 실제로는 JVM 버전, 표준 라이브러리, OS 기능 의존성 때문에 “얼마나까지 이식적인지”를 따져볼 여지가 있습니다.

예를 들어 파일 경로나 줄바꿈 문자, 소켓 옵션, 스레드 스케줄링 같은 부분은 여전히 OS에 따라 동작이 달라질 수 있습니다

“JVM 위 이식성” vs “언어·프레임워크 이식성”
같은 JVM이라도 프레임워크(Spring, Netty 등)나 서드파티 라이브러리가 OS별 기능을 감싸는 방식에 따라 이식성 수준이 달라집니다.

즉, 자바 언어 자체보다 “JVM + 표준 라이브러리 + 선택한 프레임워크”까지 포함한 스택 전체를 어디까지 이식적으로 설계했는지가 중요합니다.

이식성과 성능/제어권의 트레이드오프
OS·하드웨어 디테일을 추상화할수록 이식성은 올라가지만, 세밀한 튜닝이나 특정 플랫폼의 최신 기능 활용은 어려워집니다.

반대로 JNI, Panama 같은 네이티브 연동을 많이 쓰면 이식성은 떨어지지만 성능·제어권은 올라가고, 빌드·배포 복잡도도 함께 증가합니다.

설계 관점에서의 이식성
도메인 로직을 인프라 세부사항(파일시스템, 메시징 시스템, 특정 DB 드라이버 등)에서 얼마나 분리하느냐에 따라 “언어가 주는 이식성” 이상을 얻을 수도, 망칠 수도 있습니다.

포트·어댑터(헥사고날 아키텍처) 같은 패턴은 자바의 JVM 이식성을 “설계 이식성”과 결합시켜 실질적인 플랫폼 독립성을 높이는 방향으로 쓰입니다.

OS 관점에서 바라보는 이식성
구조적으로 어디까지가 이식성인가?
자바 코드는 바이트코드까지만 “진짜로” 플랫폼 독립이고, 그 아래 JVM 구현은 OS별로 다릅니다.

즉 “Write once, run anywhere”는 “각 OS용 JVM이 동일한 스펙을 제대로 구현했다”는 전제 위에서만 성립합니다.

OS별 JVM 구현 차이가 만드는 미묘한 차이
스레드 스케줄링, 파일 시스템, 소켓 옵션, 시그널 처리 등은 결국 OS 커널에 위임되기 때문에, 같은 바이트코드라도 응답 시간·스케줄링·리소스 사용 패턴이 달라질 수 있습니다.

예를 들어 Thread.sleep, IO 블로킹, 파일 잠금 동작은 Windows와 Linux에서 타이밍·세부 동작이 조금씩 달라질 수 있고, 이것이 동시성 버그나 성능 이슈로 표면화되기도 합니다.

“JVM은 OS에 종속적, 자바는 OS에 독립적”이라는 문장의 진짜 의미
각 OS마다 다른 JVM 바이너리가 존재하고, 이 JVM이 OS API와 상호작용하는 “어댑터” 역할을 합니다.

개발자는 JVM 위의 동일한 자바 API를 사용하지만, 실제로는 OS별 JVM이 그 API를 각기 다른 시스템 호출로 매핑하며, 이 과정에서 운영체제 특성이 드러납니다.

네이티브 연동과 이식성 붕괴 지점
JNI, 파일 경로 하드코딩, OS 전용 명령(예: ProcessBuilder로 bash 호출)은 즉시 “JVM 레벨 이식성”의 바깥으로 나가는 선택입니다.

반대로 NIO, Paths, Files, Charset 같은 표준 API를 활용하면 JVM이 OS 차이를 최대한 흡수해서 이식성을 유지하려고 합니다.
