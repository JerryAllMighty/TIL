[서론]
- 오늘은  io/nio/네트워크 심화 면접 질문 카테고리를 공유하려한다.
[내용]
[재시도]
IO → NIO → Netty로 갈수록 추상화가 증가하는데, 그 대가로 잃는 제어권은 무엇인가?
-----------
🚀 자바 NIO 심화 학습 키워드
1. 메모리와 데이터 효율 (Memory Efficiency)
Direct Buffer: JVM 힙 메모리가 아닌 운영체제의 커널 메모리를 직접 사용하여 데이터 복사 비용(CPU 오버헤드)을 줄이는 버퍼입니다.

Zero Copy (TransferTo/From): 커널 공간에서 사용자 공간을 거치지 않고 데이터를 전송하여 컨텍스트 스위칭을 최소화하는 기술입니다.

Memory Mapped File (MappedByteBuffer): 파일의 내용을 프로세스의 가상 메모리에 직접 매핑하여 대용량 파일을 매우 빠르게 읽고 쓰는 방식입니다.

Scatter / Gather: 여러 개의 버퍼에 데이터를 나누어 쓰거나(Scatter), 여러 버퍼의 내용을 한 번에 읽어서 전송(Gather)하여 입출력 효율을 높이는 기법입니다.

2. 네트워크 및 동시성 (Scalability)
Reactor Pattern: Selector를 사용하여 여러 이벤트(연결, 데이터 도착 등)를 감지하고, 이를 전담 핸들러에게 분배하여 처리하는 NIO의 기본 설계 패턴입니다.

Acceptor / Handler: Selector에서 발생한 이벤트를 분류하여 새로운 연결은 Acceptor가, 실제 데이터 읽고 쓰기는 Handler가 담당하도록 역할을 분리하는 방식입니다.

SelectionKey Status: 채널의 상태(OP_ACCEPT, OP_READ, OP_WRITE 등)를 비트마스크로 관리하여 현재 입출력이 가능한 상태인지 판별하는 메커니즘입니다.

Edge Triggered vs Level Triggered: 상태가 변화하는 순간에만 이벤트를 발생시킬 것인지, 아니면 상태가 유지되는 동안 계속 발생시킬 것인지에 대한 이벤트 통지 방식입니다.

3. 비동기 및 현대적 처리 (Advanced I/O)
AIO (Asynchronous I/O): 작업을 던져놓고 완료되면 콜백(Callback)이나 Future를 통해 통지받는 완전 비동기 방식의 NIO2 API입니다.

CompletionHandler: AIO에서 입출력 작업이 성공하거나 실패했을 때 실행될 로직을 정의하는 비동기 콜백 인터페이스입니다.

Thread Pooling in NIO: Selector가 감지한 이벤트를 실제 비즈니스 로직으로 넘길 때 작업 스레드 풀을 어떻게 운영하여 병목을 방지할지에 대한 전략입니다.

[재시도]
🔹 TCP / OS 레벨

TIME_WAIT은 왜 필요하고, 서버에서 많아지면 어떤 문제가 생기나요?

🔹 Socket / OS 자원

자바에서 Socket을 닫았는데도 포트가 바로 반환되지 않는 이유는 무엇인가요?

🔹 Blocking vs Non-blocking

Non-blocking I/O가 스레드 수를 줄일 수 있는 구조적 이유는 무엇인가요?

🔹 Selector / 이벤트 모델

Selector 하나로 여러 채널을 처리할 수 있는 이유는 무엇인가요?

🔹 버퍼 / 메모리

Direct Buffer는 언제 성능 이점보다 위험이 더 커지나요?

🔹 Zero Copy

Zero Copy는 어떤 복사를 제거하며, 언제 효과가 가장 큰가요?

🔹 비동기 모델

Event Loop 구조에서 블로킹 코드가 왜 치명적인가요?

🔹 Netty

Netty는 왜 EventLoop당 하나의 스레드 모델을 유지하나요?

🔹 HTTP 심화

Keep-Alive가 있는데도 Connection Pool이 필요한 이유는 무엇인가요?

🔹 장애 / Timeout

네트워크 타임아웃을 반드시 설정해야 하는 이유는 무엇인가요?

🔹 보안 (TLS)

TLS 핸드셰이크가 비싼 이유는 무엇인가요?

------------------------------------------------------------------------
1TCP 상태 머신 (LISTEN / SYN_SENT / ESTABLISHED / TIME_WAIT)
→ TCP 연결의 생성·유지·종료 과정을 상태 전이로 관리하는 메커니즘입니다.

TIME_WAIT이 왜 필요한가요?
→ 지연된 패킷이 다음 연결에 영향을 주지 않도록 이전 연결을 안전하게 정리하기 위해서입니다.

TIME_WAIT과 서버 포트 고갈의 관계는 무엇인가요?
→ TIME_WAIT 소켓이 많아지면 사용 가능한 포트가 줄어 포트 고갈이 발생할 수 있습니다.

Half-open connection이란 무엇인가요?
→ 한쪽은 연결이 완료됐다고 생각하지만 반대쪽은 연결이 완료되지 않은 상태입니다.

SYN만 보내고 ACK가 오지 않는 상황은 어떤 문제인가요?
→ 서버 리소스를 점유만 하고 연결을 완료하지 않는 Half-open 상태를 유발합니다.

SYN Flood 공격이란 무엇인가요?
→ 대량의 SYN 요청으로 서버의 연결 큐를 고갈시키는 DoS 공격입니다.

Nagle 알고리즘이란 무엇인가요?
→ 작은 패킷을 모아서 한 번에 전송해 네트워크 효율을 높이는 전략입니다.

Nagle과 Delayed ACK의 트레이드오프는 무엇인가요?
→ 지연(latency)은 늘어나지만 처리량(throughput)은 증가합니다.




Socket과 File Descriptor의 관계는 무엇인가요?
→ 자바 Socket은 내부적으로 OS의 File Descriptor를 감싸는 추상화 객체입니다.

자바 소켓과 GC의 관계는 무엇인가요?
→ Socket 객체는 GC 대상이지만, 네이티브 FD는 명시적 close가 필요합니다.

Blocking Socket과 Non-blocking Socket의 차이는 무엇인가요?
→ Blocking은 I/O 완료까지 대기하고, Non-blocking은 즉시 반환합니다.

Socket과 SocketChannel의 차이는 무엇인가요?
→ Socket은 Blocking 기반, SocketChannel은 Non-blocking 및 Selector 기반입니다.

Blocking과 Non-blocking의 OS syscall 차이는 무엇인가요?
→ Non-blocking은 커널에서 즉시 상태를 반환하고 대기하지 않습니다.

SO_TIMEOUT 옵션은 무엇인가요?
→ read 호출의 최대 대기 시간을 제한하는 옵션입니다.

TCP_NODELAY는 어떤 옵션인가요?
→ Nagle 알고리즘을 비활성화해 지연 없이 즉시 전송하도록 합니다.

SO_REUSEADDR는 어떤 역할을 하나요?
→ TIME_WAIT 상태의 포트를 재사용할 수 있게 합니다.

Selector 내부 동작은 어떻게 이루어지나요?
→ 여러 채널의 이벤트를 OS 이벤트 큐를 통해 감시합니다.

select / poll / epoll의 차이는 무엇인가요?
→ epoll은 이벤트 기반으로 대량 연결에서도 효율적으로 동작합니다.

Linux에서 NIO 성능이 좋은 이유는 무엇인가요?
→ epoll 기반 구현으로 대규모 동시 연결 처리에 유리하기 때문입니다.

Selector.wakeup()은 왜 필요한가요?
→ 블로킹 중인 select를 즉시 깨우기 위해서입니다.

멀티 스레드 환경에서 wakeup의 역할은 무엇인가요?
→ 다른 스레드에서 Selector 상태 변경을 안전하게 반영하기 위해 사용됩니다.

Busy Loop 문제란 무엇인가요?
→ select가 계속 즉시 반환되며 CPU를 100% 사용하는 현상입니다.


Heap Buffer와 Direct Buffer의 차이는 무엇인가요?
→ Heap은 GC 관리 대상, Direct는 네이티브 메모리를 사용합니다.

언제 Direct Buffer를 사용하나요?
→ 대용량 I/O처럼 복사 비용을 줄여야 할 때 사용합니다.

Zero Copy란 무엇인가요?
→ 사용자 공간을 거치지 않고 커널에서 직접 데이터를 전송하는 방식입니다.

FileChannel.transferTo()의 역할은 무엇인가요?
→ 파일 데이터를 커널 레벨에서 네트워크로 직접 전송합니다.

ByteBuffer의 position / limit / capacity는 무엇을 의미하나요?
→ 읽기·쓰기 위치, 유효 데이터 범위, 전체 버퍼 크기를 나타냅니다.

flip과 compact의 차이는 무엇인가요?
→ flip은 읽기 전환, compact는 남은 데이터를 앞으로 당겨 재사용합니다.


Reactor Pattern이란 무엇인가요?
→ 이벤트 감지와 처리를 분리해 비동기 I/O를 처리하는 패턴입니다.

Netty와 Spring WebFlux의 근간은 무엇인가요?
→ Reactor 기반 이벤트 루프 모델입니다.

Proactor Pattern이란 무엇인가요?
→ OS가 I/O 완료까지 책임지고 완료 결과만 통지하는 모델입니다.

Java에서 Proactor가 제한적인 이유는 무엇인가요?
→ OS 의존성이 크고 JVM 추상화 한계가 있기 때문입니다.


Netty Channel Pipeline이란 무엇인가요?
→ I/O 이벤트를 Handler 체인으로 처리하는 구조입니다.

Inbound / Outbound Handler의 역할 차이는 무엇인가요?
→ Inbound는 수신, Outbound는 송신 로직을 담당합니다.

디코딩과 비즈니스 로직을 분리하는 이유는 무엇인가요?
→ 책임 분리로 유지보수성과 확장성을 높이기 위해서입니다.

EventLoopGroup에서 Boss / Worker를 나누는 이유는 무엇인가요?
→ 연결 수락과 데이터 처리를 분리해 병목을 줄이기 위해서입니다.

Netty의 Back Pressure는 어떻게 동작하나요?
→ 쓰기 가능 여부를 기준으로 송신 속도를 제어합니다.


HTTP/1.1과 HTTP/2의 가장 큰 차이는 무엇인가요?
→ HTTP/2는 하나의 연결에서 멀티플렉싱을 지원합니다.

HOL Blocking이란 무엇인가요?
→ 하나의 요청 지연이 전체 응답을 막는 현상입니다.

Keep-Alive와 Connection Pool의 관계는 무엇인가요?
→ Keep-Alive가 있어야 커넥션 풀이 재사용 효과를 냅니다.

Chunked Transfer Encoding이란 무엇인가요?
→ 응답 크기를 알 수 없을 때 데이터를 나눠 전송하는 방식입니다.


네트워크 장애는 어떻게 분류할 수 있나요?
→ 연결 실패, 지연, 부분 실패로 나눌 수 있습니다.

connect / read / write timeout의 차이는 무엇인가요?
→ 연결, 수신, 송신 단계별 최대 대기 시간을 제한합니다.

Retry가 위험한 이유는 무엇인가요?
→ 중복 요청으로 데이터 불일치나 장애 확산을 유발할 수 있습니다.

Idempotency가 중요한 이유는 무엇인가요?
→ 재시도 시에도 결과가 동일함을 보장하기 위해서입니다.


TLS 세션 재사용이란 무엇인가요?
→ 기존 세션 정보를 활용해 핸드셰이크 비용을 줄이는 방식입니다.

Full Handshake와 Resumption의 차이는 무엇인가요?
→ Resumption은 인증 단계를 생략해 빠르게 연결합니다.

mTLS란 무엇인가요?
→ 서버와 클라이언트가 서로 인증서를 검증하는 방식입니다.

인증서 체인 검증이란 무엇인가요?
→ 서버 인증서가 신뢰 가능한 Root CA까지 이어지는지 확인하는 과정입니다.
