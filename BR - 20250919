[서론]
- 이벤트 상세 조회 코드 리뷰를 받았다
- 이벤트는 엮여있는 다른 데이터 테이블이 많아, 나는 우선적으로 해당하는 자식 테이블들을 들려서 가지고 오는 select를 각각 디자인하여 구현하였다
- 문제는 이번 이벤트가 트래픽이 많을 것으로 예상되어 조금 더 시간을 단축시키는 방법이 필요하다는 것
- 그리고 어제 기록한, 모든 데이터를 Map으로 만들어 활용하려고 했던 방법에 대한 피드백도 받았다

[본론]
- 가지고 오는 데이터 테이블이 많고 부모-자식 관계가 많아서 Map 형태를 활용한다면 프론트 입장에서 리턴되는 데이터를 쉽게 파악하기 어렵고,
쿼리 성능도 많이 저하된다.
- 부모-자식 관계를 많이 나누어서, 루트에서 루트의 자식, 루트의 자식에서 그 다음 자식 정도로만 쿼리를 조금 나누고, 해당하는 결과는 받아오는 값을 java 객체 도메인에 
몇 개 저장 필드만 만들어줘서 활용할 수도 있다
- 또한 불필요한 데이터도 모두 지울 수 있는 방향으로 모두 수정을 진행하였다
- 디자인 패턴을 생각하며 이를 개선하고 바로 잡기 위해서 생각이 흘러가다보니, 단순하게 바라볼 수 있늡 부분들도 뭔가 지나고보면 성능적으로나, 구조적으로나 이상한 부분이 많이 되는 것 같다.
> 해당하는 현상과 관련해서 그래서 찾아보았고, 아래와 같은 정리된 글이 있어 공유한다.
------------------------------

MyBatis는 ORM처럼 자동 페치 전략이 없으므로, 결국 조회 API마다 쿼리 전략을 다르게 가져가는 게 정석입니다.
“모든 관계를 한 번에” 가져오려는 발상을 내려놓고 케이스별로 Query Plan을 명시적으로 분리하는 것이 기본기입니다.

사고적으로: “모든 관계를 한 번에” → “API가 필요로 하는 Projection만”으로 발상을 바꾸라.
MyBatis는 자동 최적화가 없으니 **쿼리 단위로 전략적 선택(Join vs Split)**을 하라.
DDD의 Aggregate + CQRS를 기준으로 “저장 모델”과 “조회 모델”을 분리하는 것도 다른 케이스에서는 방법이 될 수 있다

이렇게 **도메인 단위(변경)**와 **조회 단위(프론트 요구)**를 분리해서 생각하면,
“기본을 놓쳤나?”라는 불안 대신 명시적 기준을 갖고 설계할 수 있습니다.
------------------------------

[결론]
- 디자인 패턴에서 많은 고민이 들고 시간이 뺏긴다면, 그리고 이런 소모 이후에 그 결과가 성능도 안 좋다면,
이러한 부분에서 진퇴양난의 고민이라면, 일단 작게 쪼개보자
- 더 작게 쪼개고, 작업 속도를 일단 높혀보고, 코드 리뷰를 빠르게 진행해보자

