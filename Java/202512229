[서두]
-

[내용]
- Collection 관련 클래스들


컬렉션 프레임워크는 왜 나오게 되었나?
JDK 1.2 이전에는 배열, Vector, Hashtable 등 서로 호환 안 되는 자료구조를 각자 다른 방식으로 써야 해서 API가 제각각이고 재사용성이 떨어졌다.

이를 통합하기 위해 List/Set/Map 등의 인터페이스를 정의하고, 다양한 구현체(ArrayList, LinkedList, HashSet, HashMap 등)를 공통된 규약으로 다루도록 한 것이 컬렉션 프레임워크다.

이 설계 목표는 “기능은 강력하지만 개념적으로 가벼운(small conceptual weight) API”를 제공해서, 기존 자바 프로그래머가 쉽게 익히면서도 필요한 자료구조와 알고리즘을 재사용할 수 있게 하는 것이었다.

자바에서 해결하려던 구체적 문제
중복 코드 감소: 데이터를 저장·검색·삭제·순회하는 로직을 매번 직접 구현하는 대신, 표준 컬렉션과 유틸리티 메서드(Collections.sort, Collections.binarySearch 등)를 재사용하게 했다.

일관된 추상화: Collection, List, Set, Map 인터페이스로 컬렉션을 추상화해서, 구현체를 갈아끼워도 사용하는 쪽 코드는 거의 안 바꾸도록 했다.

성능 선택권: 같은 인터페이스 아래에서 ArrayList vs LinkedList, HashSet vs TreeSet처럼 성능 특성이 다른 구현체를 상황에 맞게 선택할 수 있게 했다.

프로그래밍 언어에서 컬렉션이 필요한 이유
컬렉션(추상 자료형)은 여러 값을 하나의 집합으로 묶어 저장·조작하기 위한 개념으로, 리스트·집합·맵처럼 다양한 구조를 제공한다.

이런 구조 덕분에 각각의 값에 대해 변수를 따로 만들 필요가 없고, 추가/삭제/검색/정렬 같은 공통 연산을 일관된 방식으로 제공하여 코드 가독성과 유지보수성을 높인다.

적절한 컬렉션과 알고리즘을 쓰면 검색·삽입 시간 등을 최적화하여 대량 데이터 처리에서도 좋은 성능을 얻을 수 있다.

ArrayList와 LinkedList의 차이
각각, 왜 쓸까?
ArrayList
배열 기반으로, 인덱스를 통한 접근이 빠르지만(O(1)), 중간 데이터 삽입/삭제 시 데이터 이동으로 인해 느림(O(N)). 단일 스레드 환경에서 조회/수정 위주 작업에 유리.

연결 리스트
노드(데이터 + 다음 노드 주소) 연결 방식. 중간 데이터 삽입/삭제는 빠르지만(O(1)), 특정 인덱스 접근은 느림(O(N)). 데이터 추가/삭제가 빈번한 경우에 적합.

ArrayList의 내부 구조와 동적 크기 조정(Resizing) 과정은 어떻게 되나요?
ArrayList는 내부적으로 동적 배열(배열 기반)을 사용하며, 용량이 꽉 차면 (보통 1.5배) 더 큰 새 배열을 만들어 기존 데이터를 복사합니다. 이 과정에서 O(N)의 성능 저하가 발생할 수 있습니다.

Set
중복을 허용하지 않고, 특정 값이 “존재하는지 여부”를 빠르게 확인하기 위해 만들어진 컬렉션이라고 생각하면 쉽다.

HashSet
요소 순서를 보장하지 않음.
해시 테이블 기반으로 대부분 연산이 평균
O(1) 수준이라 가장 빠른 Set 구현에 속함

TreeSet
내부적으로 Red-Black Tree 같은 정렬 이진 트리 구조를 사용해서 항상 정렬된 상태 유지.
기본은 오름차순 정렬이고, Comparator를 주면 커스텀 정렬 가능.

연산 비용은 O(log n)
O(logn) 수준이라 HashSet/LinkedHashSet보다는 느리지만, 정렬과 범위 검색에 강함.

LinkedHashSet
내부는 HashSet처럼 해시 테이블을 쓰지만, 이중 연결 리스트로 삽입 순서를 유지.
그래서 검색 속도는 여전히 O(1)
O(1) 근처지만, 링크 관리 비용 때문에 HashSet보다 약간 느림.

언제 무엇을 쓰면 되는가?
순서 상관없고, 가장 빠른 Set이 필요 → HashSet.
삽입 순서를 유지하면서도 빠른 Set이 필요 → LinkedHashSet.
항상 정렬된 상태 + 범위/최소/최대 조회가 중요 → TreeSet.

정리하면, 세 클래스는 “중복 없는 집합”이라는 같은 문제를 풀면서, 성능 vs 순서 유지 vs 정렬/범위 연산이라는 서로 다른 요구사항을 만족하기 위해 분화된 버전이라고 보면 됩니다.
