[서두]
- 어노테이션 관련 학습 내용을 정리하려 한다



[내용]
어노테이션이란?
클래스나 메서드 선언시에 @를 쓰는 것이다.
메타데이터라고 하기도 한다.
JDK5부터 등장
주로 사용은

컴파일러에게 정보를 알려주거나
컴파일 할 때와 설치 시의 작업을 지정하거나
실행할 때 별도의 처리가 필요할 때
일 때이다.
어떤 문제를 해결하기 위해서일까?
설정이 코드와 분리되어 흩어져 있음
XML, properties, 네이밍 규칙, 주석 등으로 “이 메서드는 트랜잭션 걸어야 함”, “이 필드는 DB 컬럼” 같은 정보를 따로 관리했다.
문제: 코드와 설정이 따로 놀아서, 변경 시 동기화가 깨지고, 추적이 힘들고, 타입 안전성이 없다.

반복적인 보일러플레이트 코드
getter/setter, 빌더, equals/hashCode, DI 등록 코드 등은 패턴은 같고 내용만 다른 반복 작업이다.
문제: 손으로 쓰면 귀찮고, 실수도 많고, 변경 시 유지보수가 어렵다.

부가 기능(트랜잭션, 로깅, 보안 등) 코드가 비즈니스 로직을 오염
try-catch, 로그 출력, 권한 체크, 트랜잭션 시작/커밋 코드 등이 비즈니스 코드에 섞여서 핵심 의도가 흐려진다.

어떻게 해결을 할까?
코드 요소에 직접 붙여 의미와 설정을 선언적으로 기술
예: @Override, @Deprecated, @Entity, @Controller, @Transactional 등으로 “이 메서드는 오버라이드다”, “이 클래스는 JPA 엔티티다”, “여기 트랜잭션 걸어라”를 코드 바로 위에 명시.

컴파일러/툴/프레임워크가 이 메타데이터를 읽어 자동 처리
컴파일 타임: 어노테이션 프로세서가 코드 생성·검증(Lombok, MapStruct 등)을 수행해 보일러플레이트 제거.

런타임: 스프링, JPA, JUnit 등이 리플렉션으로 어노테이션을 읽어 DI, 매핑, 테스트 실행 등 동작을 결정.

메타 어노테이션
어노테이션을 선언하기 위한 것이다.

@Target
어노테이션을 어떤 것에 적용할지를 선언할 때 사용.

위 사진 처럼 사용을 하고,
CONTRUCTOR : 생성자
FIELD : 필드 값 선언 (enum 상수 포함)
LOCAL_VARIABLE : 지역 변수 선언
METHOD : 메서드 선언
PACKAGE : 패키지 선언
PARAMETER : 매개 변수 선언
TYPE : 클래스, 인터페이스, enum 등 선언시
등의 종류가 있다.

@Retention
얼마나 오래 어노테이션 정보가 유지되는지를 다음과 같이 선언한다.
SOURCE : 컴파일시 사라짐
CLASS : 클래스 파일에 있는 어노테이션 정보가 컴파일러에 의해서 참조 가능. 하지만, 가상 머신에서는 사라짐.
RUNTIME : 실행시 어노테이션 정보가 가상 머신의 의해서 참조 가능

@Documented
Javadocs(API) 문서에 포함된다는 것을 선언.

@Inherited
모든 자식 클래스에서 부모 클래스의 어노테이션을 사용 가능하다는 것을 선언.
