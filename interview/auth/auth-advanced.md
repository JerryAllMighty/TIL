<details> <summary>1. JWT를 사용할 때 Access Token의 유효 기간을 짧게 설정하고 Refresh Token을 사용하는 이유는 무엇인가요?</summary> <div markdown="1"> 답변: 가장 큰 이유는 보안과 사용자 편의성 사이의 절충안을 찾기 위해서입니다. JWT는 서버에서 제어권이 없는 'Stateless'한 특성을 가집니다. 만약 Access Token이 탈취되면 만료 전까지 공격자가 자유롭게 사용할 수 있는데, 이를 방지하기 위해 유효 기간을 짧게(예: 30분) 설정합니다. 하지만 매번 로그인을 시키면 사용자 경험이 저하되므로, 유효 기간이 긴(예: 2주) Refresh Token을 안전한 곳(HttpOnly Cookie 등)에 저장해 두었다가 Access Token이 만료될 때마다 서버에 제시하여 새 토큰을 발급받게 함으로써 보안성을 높이면서도 연속적인 로그인을 유지합니다. </div> </details>

<details> <summary>2. 만약 Refresh Token 자체가 탈취된다면 어떻게 대응할 수 있을까요? (Refresh Token Rotation)</summary> <div markdown="1"> 답변: Refresh Token Rotation (RTR) 기법을 사용할 수 있습니다. 클라이언트가 Refresh Token을 사용하여 새로운 Access Token을 요청할 때, 기존의 Refresh Token도 폐기하고 새로운 Refresh Token을 함께 발급하는 방식입니다. 이 방식을 사용하면, 공격자가 탈취한 옛날 토큰으로 접근했을 때 서버는 "이미 사용된 토큰"임을 감지할 수 있고, 이 경우 해당 유저의 모든 토큰 세션을 무효화하여 비정상 접근을 차단할 수 있습니다. </div> </details>

<details> <summary>3. OAuth 2.0 흐름에서 'Authorization Code' 방식이 'Implicit' 방식보다 보안상 우수한 이유는 무엇인가요?</summary> <div markdown="1"> 답변: Implicit 방식은 브라우저로 토큰이 직접 전달되어 브라우저 히스토리나 로그에 토큰이 노출될 위험이 큽니다. 반면, Authorization Code 방식은 브라우저를 통해 '코드'만 전달하고, 실제 '토큰' 발급은 백엔드 서버 대 서버 통신을 통해 이루어집니다. 이 과정에서 Client Secret을 사용하여 서버의 신원을 한 번 더 확인하기 때문에 토큰이 탈취될 가능성을 획기적으로 낮춥니다. </div> </details>

<details> <summary>4. 세션 기반 인증과 토큰 기반 인증(JWT)의 확장성(Scalability) 차이를 설명해 주세요.</summary> <div markdown="1"> 답변: 세션 방식은 기본적으로 Stateful합니다. 유저의 로그인 상태를 서버 메모리에 저장하므로, 서버가 여러 대일 경우 '세션 불일치' 문제가 발생합니다. 이를 해결하기 위해 Sticky Session이나 별도의 Redis 세션 저장소가 필요합니다. 반면 JWT는 Stateless합니다. 인증에 필요한 모든 정보가 토큰 자체에 담겨 있어 서버는 별도의 저장소 조회 없이 서명만 검증하면 됩니다. 따라서 어떤 서버로 요청이 가더라도 인증이 가능하므로 로드 밸런싱과 MSA(마이크로서비스 아키텍처) 환경에서 확장이 매우 유리합니다. </div> </details>

<details> <summary>5. JWT의 Payload는 암호화되지 않는데, 여기에 민감한 정보를 담아도 될까요? 아니라면 어떻게 해야 하나요?</summary> <div markdown="1"> 답변: 절대 안 됩니다. JWT의 Payload는 단순히 Base64로 인코딩되어 있을 뿐, 누구나 열어볼 수 있는 평문과 같습니다. 따라서 비밀번호나 주민번호 같은 민감 정보는 담아서는 안 되며, 유저를 식별할 수 있는 최소한의 정보(PK값, Role 등)만 담아야 합니다. 만약 데이터 자체를 암호화해야 한다면 JWE(JSON Web Encryption) 표준을 사용하거나, 백엔드 DB에서 해당 식별자로 정보를 다시 조회하는 방식을 택해야 합니다. </div> </details>