[서두]
- 오늘은 제네릭 관련해서 다시 한 번 정리했다.
솔직히 좀 어렵다... 전부 다시 타이핑해보면서 내 것으로 소화하는 시간을 가져야한다.
[내용]
왜 쓰는 걸까 제네릭?
코드 재사용
타입마다 ListInt, ListString 같은 클래스를 따로 만들 필요 없이, List처럼 하나로 통일해서 재사용할 수 있게 한다.

타입 안전성
컴파일 시점에 타입을 체크해서, 잘못된 형 변환이나 ClassCastException 같은 오류를 미리 잡는다 (예: List에는 Int를 넣을 수 없음).

더 나은 IDE 지원
구체적인 타입 정보가 있으니 자동완성, 리팩터링, 정적 분석 등 도구 지원이 훨씬 정확해진다.

옛날 Java 스타일 (제네릭 도입 전)
컬렉션에 Object를 넣고, 꺼낼 때 캐스팅을 했다가 잘못 캐스팅하면 런타임에 ClassCastException이 나는 식

Bounded WildCard
자바의 bounded wildcard(예: ? extends T, ? super T)는 “제네릭의 타입 안전성은 유지하면서, API를 더 유연하게 재사용하기 위해” 나온 개념이다. 특히 List와 List 같은 서로 다른 제네릭 타입들을 한 메서드에서 다루면서도 컴파일 타임 타입 체크를 유지하려는 요구 때문에 등장했다.

어떤 문제가 있었는지
공변성 부족 문제 (List vs List)

자바 제네릭은 기본적으로 불공변이라 List는 List의 상위 타입이 아니다.

그래서 “숫자 리스트라면 다 받아서 합을 구하는 메서드” 같은 걸 void sum(List list)로 만들면 List나 List을 넘길 수 없었다.

이 불편을 해결하려고 “Number의 하위 타입을 담은 리스트라면 다 받아라”라는 표현이 필요했고, 그것이 List<? extends Number> 같은 상한 경계 와일드카드다.

읽기 전용 vs 쓰기 전용 역할 분리 문제
List<?> 같이 타입을 모르는 컬렉션은 “뭔가를 안전하게 꺼내 읽는 것”은 가능하지만, 구체 타입을 모르기 때문에 안전하게 add를 할 수 없다.

반대로 “이 컬렉션에는 최소한 Integer 이상은 넣을 수 있게 하고 싶다” 같은 요구가 있을 때, 상위 타입을 기준으로 넣기 전용처럼 쓰고 싶은 경우가 생긴다.

이때 List<? super Integer> 같은 하한 경계 와일드카드를 쓰면 “Integer 혹은 그 상위 타입을 요소로 받는 컬렉션”이라고 표현할 수 있어서 안전하게 add(new Integer(...))를 할 수 있다.

왜 bounded wildcard 인가
API 유연성 극대화
동일한 로직인데 제네릭 매개변수 타입만 살짝 다른 여러 오버로드를 만들 필요 없이, 한 번 정의한 메서드를 다양한 제네릭 인스턴스에 대해 재사용할 수 있게 해준다.
대표적인 패턴이 “Producer-Extends, Consumer-Super(PECS)”로,
값을 꺼내기만 하는 쪽은 <? extends E>를 쓰고,
값을 넣기만 하는 쪽은 <? super E>를 쓰라는 가이드가 이 패턴에서 나온다.

타입 매개변수(T)와 용도가 다름
class Box 같은 bounded type parameter는 “클래스를 정의할 때” 그 타입 자체의 범위를 제한하는 개념이다.

반대로 Box<? extends Number> 같은 bounded wildcard는 “이미 정의된 제네릭 타입을 사용할 때” 그 인스턴스의 허용 범위를 표현하기 위한 것이라서, 기존 API를 더 넓은 타입 계층에 대해 쓸 수 있게 해준다.

한 줄로 요약하면
문제: 제네릭 불공변성 때문에 List·List 등을 한 번에 처리하는 유연한 API를 만들기 어려웠고, 읽기/쓰기 방향에 따른 타입 안전성을 표현하기도 애매했다.

해결: bounded wildcard로 “이 컬렉션은 T의 하위 타입들을 생산한다(extends)” 또는 “이 컬렉션은 T의 상위 타입으로 요소를 소비한다(super)”를 명시적으로 표현해, 타입 안전성을 잃지 않으면서 API 유연성을 높였다.
