DAO & 드라이버
<details>
<summary>관심사의 분리(Separation of Concerns)를 이해하고 있는가?</summary>
<div markdown="1">
하나의 객체나 모듈이 여러 종류의 책임을 지지 않도록, 서로 다른 이유로 변경되는 코드들을 분리하는 것
</div>
</details>


<details>
<summary>팩토리 메서드 패턴은 무엇인가?</summary>
<div markdown="1">
객체 생성 책임을 분리해 구체 클래스 결정은 서브클래스나 팩토리에 위임하는 생성 패턴이다.
</div>
</details>

<details>
<summary>객체의 다형성이란 무엇인가?</summary>
<div markdown="1">
같은 인터페이스로 서로 다른 구현 객체를 동일하게 다룰 수 있는 객체지향 특성이다.

객체의 다형성은 서로 다른 클래스의 객체들이 같은 메시지(메서드 호출)에 대해 각자 다른 방식으로 응답할 수 있는 능력을 말한다.
주로 상속과 인터페이스를 통해, 상위 타입(인터페이스/추상 클래스)으로 여러 하위 타입을 한꺼번에 다루면서, 실제 런타임 타입에 따라 오버라이딩된 메서드가 호출되도록 함으로써 유연하고 재사용 가능한 코드를 작성할 수 있다
</div>
</details>

<details>
<summary>다형성이 관심사의 분리와 어떤 관계가 있나요?</summary>
<div markdown="1">
구현이 아닌 역할에 의존하게 만들어 변경 영향을 최소화한다.

다형성을 사용하면 구현체가 아닌 역할(인터페이스)에 의존하게 되어,
구현 변경이 사용 코드에 영향을 주지 않는다.
이는 관심사의 분리를 가능하게 하는 핵심 요소이다.
</div>
</details>

<details>
<summary>상속이 아닌 인터페이스 기반 설계를 강조하는 이유는 무엇인가요?</summary>
<div markdown="1">
구현 결합을 피하고 변경과 확장에 유연한 구조를 만들기 위해서다.
상속은 구현에 강하게 결합되지만,
인터페이스는 역할에만 의존하게 만든다.
변경과 확장에 더 유연한 구조를 만들 수 있다.
</div>
</details>


<details>
<summary>객체지향 설계 원칙이란 무엇인가?</summary>
변경에 유연하고 유지보수성이 높은 설계를 위한 가이드라인(SOLID 등)이다.

객체지향 설계 원칙은 변경에 유연하고 재사용성과 유지보수성이 높은 소프트웨어를 만들기 위해 제안된 일련의 가이드라인으로, 대표적으로 SOLID 원칙이 널리 사용된다.
SOLID는 단일 책임 원칙, 개방-폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존 역전 원칙의 약자로, 각 원칙은 클래스의 책임 분리, 확장 용이성, 안정적인 상속 관계, 인터페이스 최소화, 추상화에 대한 의존 등을 통해 결합도를 낮추고 응집도를 높이는 것을 목표로 한다.
<div markdown="1">
</div>
</details>

<details>
<summary>DAO의 역할은 무엇이며, 왜 분리해야 하나요?</summary>
<div markdown="1">
데이터 접근 로직을 전담해 비즈니스 로직과의 결합을 낮추기 위해서다.
DAO는 데이터 접근 로직을 전담하는 객체이다.
비즈니스 로직과 데이터 접근 로직을 분리함으로써
변경에 유연하고 테스트하기 쉬운 구조를 만들 수 있다.
</div>
</details>

<details>
<summary>JDBC 드라이버를 직접 사용하면 어떤 문제가 발생하나요?</summary>
<div markdown="1">
데이터 접근 코드와 비즈니스 로직이 섞여 변경과 테스트가 어려워진다.
드라이버, 커넥션 생성, 예외 처리, 리소스 반환 코드가
비즈니스 로직과 섞이게 되어 코드 중복과 변경 비용이 커진다.
관심사의 분리가 깨진다.
</div>
</details>



제어의 역전 (IoC)

<details>
<summary>IoC와 DI의 관계를 설명해보세요.</summary>
<div markdown="1">
IoC는 원칙이고 DI는 이를 구현하는 대표적인 방법이다.
IoC는 제어권이 외부로 넘어간다는 원칙이고,
DI는 IoC를 구현하는 구체적인 방법 중 하나이다.
스프링은 DI를 통해 IoC를 실현한다.
</div>
</details>


<details>
<summary>DI를 사용하지 않고도 IoC는 가능한가요?</summary>
<div markdown="1">
가능하다.
가능하지만 DI가 가장 명확하고 테스트하기 좋은 방식이다.
팩토리 메서드, 서비스 로케이터 패턴 등도 IoC의 한 형태이다.
DI는 가장 명확하고 테스트 친화적인 방식이다.
</div>
</details>


<details>
<summary>DI의 3가지 조건 중 하나라도 빠지면 어떤 문제가 생기나요?</summary>
<div markdown="1">
구현 교체와 유연한 확장이 어려워져 IoC 효과가 약해진다.

인터페이스 의존이 없으면 구현 교체가 어렵고,
런타임 결정이 아니면 유연성이 떨어지며,
제3자의 개입이 없으면 IoC가 성립하지 않는다.
세 조건은 함께 충족되어야 한다.
</div>
</details>


<details>
<summary>팩토리란 무엇인가?</summary>
객체 생성 책임을 캡슐화해 클라이언트의 구현 의존을 제거하는 역할이다.

팩토리는 객체 생성 로직을 캡슐화하여, 클라이언트가 구체적인 생성 과정이나 클래스 이름을 알지 못해도 요청만으로 적절한 객체 인스턴스를 돌려주는 역할을 하는 구성 요소이다.
이를 통해 객체 생성 책임을 한 곳으로 모으고, 생성 정책을 변경하거나 새로운 타입을 도입할 때 클라이언트 코드를 최소한으로 변경하면서 시스템을 확장할 수 있다.
<div markdown="1">
</div>
</details>

<details>
<summary>팩토리를 도입하면 어떤 책임이 분리되나요?</summary>
<div markdown="1">
객체 생성 책임이 사용 책임과 분리된다.

객체를 사용하는 코드는 생성 방식이나 구현체 변경에 영향을 받지 않는다.
</div>
</details>

<details>
<summary>new 키워드 사용이 문제가 되는 이유는 무엇인가요?</summary>
<div markdown="1">
구체 클래스와 생성 시점에 대한 강한 결합을 만든다.

new 키워드는 구체 클래스에 대한 의존을 만들고,
객체 생성 시점을 코드에 고정시킨다.
이는 변경과 테스트를 어렵게 만든다.
</div>
</details>



<details>
<summary>빈과 빈 팩토리는 무엇인가?</summary>
<div markdown="1">
빈은 컨테이너가 관리하는 객체이고, 빈 팩토리는 이를 생성·관리하는 최소 컨테이너이다.

스프링에서 빈(Bean)은 스프링 IoC 컨테이너가 생성·관리·의존성 주입까지 책임지는 관리 대상 객체를 의미한다.
빈 팩토리(BeanFactory)는 이러한 빈들을 생성하고 의존성을 주입하며 생명주기를 관리하는 최소한의 기능을 가진 스프링 IoC 컨테이너의 기본 인터페이스로, 설정 메타데이터를 읽어 필요한 시점에 빈을 생성·제공한다
</div>
</details>

<details>
<summary>애플리케이션 컨텍스트란 무엇인가?</summary>
<div markdown="1">
BeanFactory를 확장해 엔터프라이즈 기능까지 제공하는 스프링 IoC 컨테이너이다.

애플리케이션 컨텍스트(ApplicationContext)는 BeanFactory를 확장한 스프링의 고급 IoC 컨테이너로, 빈 관리 기능에 더해 AOP 연동, 메시지 소스, 이벤트 발행 등 엔터프라이즈 애플리케이션에 필요한 여러 부가 기능을 제공한다.
일반적인 스프링 애플리케이션에서는 BeanFactory 대신 ApplicationContext를 사용하며, 애플리케이션 전역에서 사용할 빈들을 미리 로딩하고 의존성을 주입하여 런타임에 손쉽게 조회·사용할 수 있게 한다.


</div>
</details>

<details>
<summary>애플리케이션 컨텍스트의 동작원리에 대해 설명해보라</summary>
<div markdown="1">
설정 정보를 기반으로 객체 생성, 의존성 주입, 생명주기를 관리한다.

애플리케이션 컨텍스트는 먼저 설정 정보(자바 설정 클래스, XML, 애노테이션 스캔 등)를 읽어 빈 정의 메타데이터를 구성하고, 이 정보를 바탕으로 빈들의 생성 방식과 의존 관계를 분석한다.
컨텍스트 초기화 시 이 메타데이터에 따라 필요한 빈을 인스턴스화하고, 의존성 주입과 라이프사이클 콜백, 후처리기를 적용한 뒤 컨테이너 내부에 캐싱하여, 이후에는 getBean이나 자동 주입을 통해 동일한 빈 인스턴스를 제공함으로써 애플리케이션 전역의 객체 그래프를 일관되게 관리한다.
</div>
</details>

<details>
<summary>빈 팩토리와 애플리케이션 컨텍스트의 차이는 무엇인가요?</summary>
<div markdown="1">
애플리케이션 컨텍스트는 빈 관리 외에 AOP, 이벤트 등 부가 기능을 제공한다.

빈 팩토리는 빈 생성과 조회에 집중하고,
애플리케이션 컨텍스트는
트랜잭션, AOP, 메시지, 이벤트 등 엔터프라이즈 기능을 추가로 제공한다.
</div>
</details>




<details>
<summary>동일성과 동등성은 어떻게 다른가?</summary>
<div markdown="1">
동일성은 참조 비교이고, 동등성은 값의 논리적 비교이다.

동일성(identity)은 두 참조가 메모리상에서 정확히 같은 객체 인스턴스를 가리키는가를 의미하며, 자바에서는 == 연산자가 이를 비교한다.
동등성(equality)은 두 객체의 내용(상태나 값)이 논리적으로 같은가를 의미하며, 자바에서는 equals 메서드로 정의·비교하며, 서로 다른 인스턴스라도 같은 값으로 간주될 수 있다는 점에서 동일성과 구분된다.


</div>
</details>

<details>
<summary>싱글톤 패턴이란?</summary>
<div markdown="1">
애플리케이션 내에서 하나의 인스턴스만 존재하도록 보장하는 패턴이다.

싱글톤 패턴은 어떤 클래스의 인스턴스를 애플리케이션 전체에서 오직 하나만 존재하도록 보장하고, 그 전역 인스턴스에 접근할 수 있는 공용 수단을 제공하는 생성 패턴이다.
이를 위해 생성자를 외부에서 호출하지 못하게 제한하고(예: private 생성자), 클래스 내부에 유일한 인스턴스를 저장한 뒤 정적 메서드 등을 통해 동일한 인스턴스를 반복 제공하여, 공유 자원 관리나 전역 설정 같은 역할을 수행하게 한다
</div>
</details>

<details>
<summary>객체의 생성과 생명주기 제어권을 본인이 아닌 외부(컨테이너)에 위임하는 이유는?</summary>
<div markdown="1">
결합도를 낮추고 객체가 역할에만 집중하도록 하기 위해서다.

객체 간의 결합도를 낮추고, 객체가 본연의 비즈니스 로직에만 집중하게 하기 위해서입니다.
객체가 스스로 사용할 구현 클래스를 결정하고 생성하면 강한 결합이 생깁니다. 
제어권을 컨테이너(외부)에 넘기면, 객체는 어떤 구체적인 객체가 주입될지 몰라도 자신의 역할만 수행하면 되므로 유연한 확장이 가능해집니다.
</div>
</details>


의존관계 주입 (DI)
<details>
<summary>DI의 세 가지 조건(인터페이스 의존, 런타임 결정, 제 3자의 개입)을 설명할 수 있는가?</summary>
<div markdown="1">
인터페이스에 의존하고, 구현체는 런타임에 결정되며, 그 연결은 제3자(컨테이너)가 담당한다.

1. 인터페이스 의존: 설계 시점에는 구체적인 클래스를 알지 못한 채 인터페이스에만 의존해야 합니다.
2. 런타임 결정: 실제 사용될 구체적인 객체는 애플리케이션이 실행되는 시점에 결정됩니다.
3. 제 3자의 개입: 두 객체 사이의 관계를 맺어주는 외부 존재(스프링 컨테이너/Assembler)가 반드시 필요합니다.
</div>
</details>

<details>
<summary>의존 관계 주입과 의존 관계 검색의 차이는 무엇인가?</summary>
<div markdown="1">
DI는 외부에서 의존성을 주입받고, DL은 객체가 직접 컨테이너에서 의존성을 조회한다.
</div>
</details>


싱글톤 레지스트리
<details>
<summary>스프링 빈이 기본적으로 싱글톤인 이유와, 멀티쓰레드 환경에서의 주의점(상태 유지 X)은?</summary>
<div markdown="1">
객체 생성을 최소화해 성능을 확보하되, 여러 스레드가 공유하므로 반드시 무상태로 설계해야 한다.

서버 환경은 수많은 요청이 동시에 들어오는데, 요청마다 객체를 생성하면 메모리 부하와 가비지 컬렉션(GC) 부담이 너무 커지기 때문
여러 쓰레드가 공유하므로 상태 정보(인스턴스 변수)를 가지지 않는 무상태(Stateless) 방식으로 설계해야 합니다. 즉, 로컬 변수나 파라미터를 사용해야 데이터가 꼬이지 않습니다.
</div>
</details>

<details>
<summary>스프링 빈의 스코프에 대해서 설명하라?</summary>
<div markdown="1">
빈 스코프는 빈의 생성부터 소멸까지의 생명주기 범위를 의미하며 기본은 싱글톤이다.

스프링 빈의 스코프는 빈이 생성되고 존재하며 소멸하는 생명주기 범위를 정의하며, 기본값은 싱글톤이다
</div>
</details>


<details>
<summary>싱글톤 패턴과 스프링 싱글톤의 차이는 무엇인가요?</summary>
<div markdown="1">
싱글톤 패턴은 코드로 직접 제어하고, 스프링 싱글톤은 컨테이너가 생명주기를 관리한다.

싱글톤 패턴은 클래스 레벨에서 인스턴스를 제어하고,
스프링 싱글톤은 컨테이너가 객체 생명주기를 관리한다.
스프링 방식이 테스트와 확장에 유리하다.
</div>
</details>

<details>
<summary>왜 상태를 가지는 싱글톤 빈은 위험한가요?</summary>
<div markdown="1">
여러 스레드가 동시에 접근해 상태 값이 꼬이는 동시성 문제가 발생할 수 있기 때문이다.

싱글톤 빈은 여러 스레드가 동시에 접근한다.
상태를 가지면 동시성 문제가 발생할 수 있으므로
무상태(stateless)로 설계해야 한다.
</div>
</details>




전략 패턴 (Strategy Pattern)
<details>
<summary>변하지 않는 맥락(Context) 속에서 변하는 로직(Strategy)을 분리해 보았는가?</summary>
<div markdown="1">
변하는 알고리즘을 전략 인터페이스로 분리해 상황에 따라 교체 가능하게 만든 패턴이다.

기능을 구현한 알고리즘(전략)을 인터페이스로 캡슐화하고, 이를 상황에 따라 교체해서 사용하는 패턴
</div>
</details>

<details>
<summary>전략 패턴이 OCP를 만족시키는 이유는 무엇인가요?</summary>
<div markdown="1">
기존 코드 수정 없이 새로운 전략 구현체 추가만으로 기능 확장이 가능하기 때문이다.

기존 코드를 수정하지 않고
새로운 전략 구현체를 추가하는 방식으로 기능을 확장할 수 있기 때문이다.
이는 OCP의 핵심 의도를 코드로 구현한 것이다.
</div>
</details>

<details>
<summary>OCP를 위반하는 전형적인 코드 예시는 무엇인가요?</summary>
<div markdown="1">
if-else나 switch 문으로 구현체를 분기하는 코드이다.
기능 추가 시 기존 코드를 수정해야 하므로 OCP를 위반한다.
</div>
</details>




개방 폐쇄 원칙 (OCP)
<details>
<summary>기능 확장에는 열려 있고 변경에는 닫혀 있다는 말이 코드 수준에서 어떻게 구현되는가?</summary>
<div markdown="1">
인터페이스와 다형성을 통해 기존 코드 수정 없이 새로운 구현체를 추가하는 방식으로 구현된다.

인터페이스와 다형성을 통해 구현됩니다.
새로운 DB를 추가하고 싶을 때(확장에는 열림), 기존의 UserDao 소스 코드를 단 한 줄도 수정하지 않고(변경에는 닫힘) 새로운 드라이버 클래스를 만들어 인터페이스를 구현하기만 하면 되는 상태를 의미합니다.
</div>
</details>


<details>
<summary>컨테이너/ IoC 컨테이너에 대해서 설명하라</summary>
<div markdown="1">
IoC 컨테이너는 객체의 생성, 의존성 주입, 생명주기를 관리해 결합도를 낮추고 확장성과 테스트성을 높인다.


컨테이너란 소프트웨어에서 컨테이너는 객체의 생명주기(Life Cycle)를 관리하고 필요한 서비스를 제공하는 공간을 의미합니다.
우리가 흔히 쓰는 서블릿 컨테이너(Tomcat 등)가 서블릿의 생성과 소멸을 관리하듯, 스프링 컨테이너는 우리가 만든 '객체(Bean)'들을 관리합니다.
스프링에서 객체(Bean)를 생성하고, 서로 연결(의존성 주입)해주며, 소멸까지 책임지는 주체입니다.
왜 사용하는가? (Product Engineer의 관점)
유연한 확장: 객체 간의 결합도가 낮아지므로, 부품(객체)을 교체하기가 매우 쉽습니다. (예: JDBC에서 JPA로 DB 접근 로직을 바꿀 때 코드 수정 최소화)
테스트 용이성: 가짜 객체(Mock)를 주입하기 쉬워져서 서비스의 안정성을 검증하기 좋습니다.
비즈니스 집중: 개발자는 객체 생성 같은 인프라적인 고민 대신, 실제 제품의 기능(Business Logic) 구현에만 에너지를 쓸 수 있습니다.
</div>
</details>
	
	
	




	



