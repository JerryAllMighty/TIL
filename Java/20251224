[서두]
- 오늘은 동일성과 동등성 관련된 것을 정리해보겠다

[내용]
Object 클래스를 공부하다가 알게되었다.
대표적인 equals 메서드와 hashCode 메서드를 공부하다보니 동일성과 동등성이라는 키워드까지 오게되었다.

- 동일성은
물리적으로 같은 객체인가?
메모리 주소를 비교하는 것

- 동등성은
논리적으로 같은 정보를 담고 있는가?
객체 내부의 값을 비교하는 것

> 예시부터 보자
동일성 (Identity, ==)
정의: JVM의 스택(Stack) 영역에 있는 변수가 힙(Heap) 영역의 같은 객체 주소를 가리키고 있는지 확인.
Primitive Type (int, long 등)은 값 자체가 스택에 저장되므로, 값이 같으면 동일.
Reference Type (객체)은 주소 값을 비교하므로, 아무리 필드 값이 똑같아도 new로 새로 생성된 객체끼리는 false가 반환.

동등성 (Equality, .equals())
정의: 서로 다른 주소를 가진 객체라도, 그 안에 담긴 데이터(상태 값)가 논리적으로 일치하는지 확인.

주의점: Object 클래스의 기본 equals() 구현은 내부적으로 == (동일성 비교)를 사용.
따로 오버라이드해서 값을 비교하는 로직을 구현한다면 이 때는 동등성을 비교하는 것이라고 판단.

// java.lang.Object의 기본 구현
public boolean equals(Object obj) {
    return (this == obj);
}
따라서, 개발자가 클래스를 설계할 때 equals()를 오버라이딩(Overriding)하여 "어떤 필드들이 같아야 동등한 것인가"를 직접 정의해 주어야 비로소 동등성 비교가 가능해짐.

- HashCode도 반드시 equals와 같이 정의해주어야하는 이유
안 해준다면 어떤 이슈가 있을까?

예시 1 :
HashCode는 기본적으로 JVM에서 16진수로 나타낸 객체의 메모리 주소를 int형으로 변환한 값. 객체를 구분할 수 있는 값이다. 하지만 정수형이기 때문에 만약에 무한한 경우가 주어진다면 중복되는 케이스가 생길 수 있다.

예시 2:
HashSet이나 HashMap 같은 해시 기반 컬렉션은 객체를 저장하거나 찾을 때 다음 순서를 따릅니다.
HashCode 비교: 찾으려는 키의 해시 코드를 계산하여 내부 버킷(Bucket) 위치를 찾습니다.
동일성(==) 비교: 버킷 안에 있는 객체의 주소가 같은지 봅니다.
동등성(equals) 비교: 주소가 다르면 equals()를 호출하여 내용이 같은지 봅니다.
만약 equals만 재정의하고 hashCode를 재정의하지 않으면, 논리적으로 같은 객체임에도 불구하고 해시 코드가 달라 엉뚱한 버킷을 뒤지게 되어 데이터를 찾지 못하는 심각한 버그가 발생합니다.

[정리]
해시값을 기반으로 탐색을 하는게 속도, 성능 면에서 더 좋기에 먼저 해시값을 기반으로 탐색.
(해시값은 정수라 비교도 빠르고, equals로 비교하는 것보다 훨씬 일관성도 있고 덜 복잡하다.
또한 다양한 객체가 들어가야해서 구현이 덜 복잡해질 수 있다.)
하지만 정수형이 기반이라 아주 낮은 확률로 같은 값이 올 가능성이 존재.
따라서 2차로 비교할 필요가 있음. 이게 equals이다.
따라서 해시코드 값이 정의되지않으면 논리적으로 같은 값이어도 해시코드 값이 다르니 1차적으로 다른 버킷 값을 뒤지게 되어 버그 발생 가능성이 있다는 것.
