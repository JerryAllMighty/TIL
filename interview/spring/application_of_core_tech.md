<details>
<summary><strong>1. 왜 SQL을 DAO 코드에서 분리하여 관리해야 하나요?</strong></summary>
<strong>질문</strong>: Java 코드 안에 SQL을 두지 않고 외부 파일(XML 등)로 추출하는 설계의 이점은?

<strong>답변</strong>:

변경의 이유와 시기가 다르기 때문입니다. 데이터 액세스 로직(Java)은 데이터 저장 방식이 바뀌지 않는 한 고정적이지만, SQL은 튜닝이나 스키마 변경으로 인해 자주 수정됩니다.

이를 분리하면 SQL 수정 시 자바 코드를 재컴파일하거나 서버를 재시작하지 않아도 되며, SQL 전문 관리자(DBA)와의 협업이 훨씬 수월해집니다.

핵심:

이것은 **관심사의 분리(Separation of Concerns)**이며, 애플리케이션의 핵심 로직을 데이터 상세 구현으로부터 보호하는 설계입니다.

</details>

<details>
<summary><strong>2. SQL 서비스 설계에 '서비스 추상화(PSA)'를 어떻게 적용했나요?</strong></summary>
<strong>질문</strong>: 다양한 위치(파일, DB, 네트워크)에 있는 SQL을 읽어오기 위한 인터페이스 설계 방식은?

<strong>답변</strong>:

SqlService라는 인터페이스를 정의하고, DAO는 구체적인 구현 방식(XML인지, JSON인지)을 몰라도 되도록 설계합니다.

내부적으로는 SQL을 읽어오는 SqlReader와 읽어온 SQL을 보관하는 SqlRegistry 인터페이스로 역할을 다시 나눕니다. 이렇게 하면 새로운 저장 매체(예: Redis)를 도입하더라도 기존의 SqlService 구현체나 DAO 코드를 수정할 필요가 없습니다.

핵심:

기술에 종속되지 않는 인터페이스를 제공함으로써 **개방-폐쇄 원칙(OCP)**을 극대화한 사례입니다.

</details>

<details>
<summary><strong>3. '자기 참조 빈(Self-referencing bean)' 설정은 왜 사용하나요?</strong></summary>
<strong>질문</strong>: 하나의 클래스가 자신을 다시 DI 받는 구조의 목적과 효용은?

<strong>답변</strong>:

책임이 다른 여러 인터페이스를 한 클래스가 구현하고 있을 때, 리팩터링의 과도기적 단계에서 사용합니다.

논리적으로는 인터페이스를 통해 분리된 것처럼 코딩하여 의존 관계를 명확히 하되, 실제 구현은 일단 한 클래스에 모아둠으로써 개발 편의성을 챙길 수 있습니다. 이후 클래스가 너무 커지면 코드 수정 없이 설정만으로 클래스를 물리적으로 분리하기가 매우 용이해집니다.

핵심:

유연한 구조를 유지하면서도 초기 개발 복잡도를 낮추기 위한 전략적인 설계 선택입니다.

</details>

<details>
<summary><strong>4. 인터페이스 분리 원칙(ISP)이 이 장에서 어떻게 드러나나요?</strong></summary>
<strong>질문</strong>: SqlRegistry 인터페이스를 더 작은 단위로 쪼개는 이유는?

<strong>답변</strong>:

특정 클라이언트(SQL 서비스)는 SQL을 "조회"만 하면 되지만, 관리 도구는 SQL을 "업데이트"해야 할 수도 있습니다.

이때 모든 기능을 하나의 인터페이스에 넣으면, 조회만 필요한 클라이언트도 불필요한 업데이트 기능에 의존하게 됩니다. 인터페이스를 용도에 맞게 쪼갬으로써 클라이언트는 자신이 사용하는 기능에만 집중할 수 있고, 변화에 따른 영향 범위를 최소화할 수 있습니다.

핵심:

인터페이스를 통해 클라이언트가 필요한 만큼만 노출하는 것은 시스템의 결합도를 낮추는 핵심 기법입니다.

</details>