[서두]
- String 관련 이슈나 내부 동작 원리를 공부하다가 좋은 글이 있어 블로그에 정리한 걸 공유한다.

[내용]
우선 둘을 왜 쓰게 된걸까?
차이는?
둘다 String 과는 다르게 한 번 만든 뒤에도 내부 버퍼 크기를 늘려가며 가변 객체이고,
문자열이 결합/수정을 반복할 때 String보다 효율적이어서 사용하게된 케이스다.
핵심 차이는 동기화이다.

StringBuffer 는 동기화를 지원한다.

실제로 모든 메서드에 synchronized 예약어가 붙은 부분을 확인할 수 있다.
멀티 스레드 환경에서 안전하단 것을 의미한다. (thread-safe)
동기화는 비용이 들기 때문에 같은 작업을 하더라도 StringBuilder 보다 보통 느리다.

반면에 StringBuilder는 동기화를 지원하지 않아서 단일 스레드 환경에서는 StringBuffer보다 더 빠릅니다.
또한 멀티 스레드 환경에서는 동시성 문제가 생길 수 있습니다.

왜 동기화가 걸려있으면 느릴까?
동기화를 한다는 건 한 번에 한 스레드만 들어가게 만들기 위해 락 획득/해제/메모리 동기화 등의 작업이 필요하다는 것을 의미한다. 이런 비용 때문에 느리다.

락 획득/해제
synchronized 예약어가 붙은 코드에 들어갈 때, JVM이 모니터 락을 얻고, 빠져나올 때 락을 반납하는 과정을 거친다.

이 과정에서 OS 수준에서 스레드를 block/unblock하거나 대기 큐 관리가 일어나면 오버헤드가 커진다.
경쟁과 대기시간
여러 스레드가 같은 락을 두고 경쟁하면, 락을 얻지 못 한 스레드는 기다리면서 CPU를 제대로 활용하지 못한다.
스레드 수가 많아질수록 Context Switching 이 잦아져 캐시를 자주 버리고 다시 채우게 되어 성능이 떨어진다.
메모리/캐시 측면의 비용
메모리 가시성 보장 비용(visibility)를 위해 락은 "이 블록 안의 읽기/쓰기 결과가 다른 스레드에서도 동일하게 보인다"는 메모리 모델 상의 보장을 함께 제공
이걸 위해서 CPU 캐시와 메인 메모리 사이에서 값 동기화, 재정렬 제한 등이 필요해 최적화 여지가 줄어든다.
그래서 같은 로직이라도 비동기 코드보다 실행이 느려질 수 있어 반복되는 동기화 로직은 비용을 아끼기 위해서 volatile, atomic 클래스, 락 범위 줄이기 등을 권장하기도 한다.
메모리 가시성 보장 비용이란게 뭘까?
Lock이 주는 보장이다.
JVM은 락 acquire와 release를 메모리 베리어로 취급해서 가시성을 보장한다.

어떤 락이 있다면 락을 끌어와 잡기전까지는 다른 곳에서의 쓰기들을 메모리에서 끌어와 보이게 하고,
언락을 할 때는 이 스레드가 락 안에서 한 쓰기들을 메인 메모리로 밀어내서 (flush) 다른 코어에서도 보이게 한다는 식의 규칙을 둔다.
이 과정에서 CPU/컴파일러에게 "이 지점 전후로는 메모리 접근 순서를 바꾸지 마라"라는 메모리 베리어/펜스 명령을 강제로 끼워 넣는다.

그럼 싱글 스레드로 접근하는 가정하에는, 둘의 성능은 똑같을까?
싱글 스레드라도 메서드마다 synchronized 키워드가 달려있다는 것은, JVM이 모니터 락을 얻어서
위에서 언급한 락 획득/해제하는 비용 등이 더 들어간다는 것이고, StringBuilder는 동기화 코드가 전혀 없어 JIT 컴파일러 최적화 여지도 있기에 차이가 발생해서 성능은 StringBuilder가 더 우수하다.

