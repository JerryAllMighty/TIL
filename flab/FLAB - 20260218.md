[서두]
- 오늘은 하루종일 프로젝트를 했다
- 하면서 혼자서 상상의 나래를 펼처보며 기술면접의 공방을 펼친다고 가정해보았다
- 난 준비되었다 내용은 이러할 거라고 가정해보았다

[내용]
<details> <summary><strong>1. 왜 UserDetails.getUsername()에서 email을 리턴했나요?</strong></summary>
<strong>질문</strong>: PK(id) 대신 email을 username으로 쓰는 이유와 영향은?

<strong>답변</strong>:

인증 식별자는 “로그인에 사용하는 값”이 기준이고, 우리 서비스에선 그게 email이다.

Spring Security는 username을 단순히 “인증에 쓰는 식별자”로만 보므로, 비즈니스 키인 email을 매핑하는 게 자연스럽다.

UserDetailsService.loadUserByUsername()가 곧 loadUserByEmail() 의미가 되어, 컨트롤러/서비스에서 사용하는 로그인 파라미터(email)와 일관성이 생긴다.

<strong>핵심</strong>:

username은 “화면에 보이는 아이디”가 아니라, “인증용 식별자”라는 기술적 개념이다.

도메인 상 고유 식별자(email)를 기술 개념(username)에 매핑하는 설계는 Spring 관례와 잘 맞는다.

</details>
<details> <summary><strong>2. Optional.get() 대신 orElseThrow()를 쓰는 이유는?</strong></summary>
<strong>질문</strong>: memberRepository.findByEmail(email).get()과 orElseThrow()의 차이와 의미?

<strong>답변</strong>:

get()은 값이 없을 때 NoSuchElementException을 던지며, 호출 지점에서 이런 예외가 나올지 직관적이지 않다.

orElseThrow(() -> new UsernameNotFoundException(...))처럼 도메인/프레임워크에 맞는 예외를 던지면, “무엇이 왜 실패했는지”가 코드에서 드러나고 상위 계층도 그 예외를 기준으로 올바르게 처리할 수 있다.

Spring Security는 loadUserByUsername에서 사용자를 찾지 못한 경우 UsernameNotFoundException을 던지도록 설계되어 있어, 표준 흐름과도 맞다.

<strong>핵심</strong>:

“숨겨진 NPE/NoSuchElement” 대신, 의미 있는 예외를 명시적으로 던져서 가독성과 에러 핸들링을 개선하는 것.

프레임워크가 기대하는 예외 타입을 맞춰 주면 인증 실패 처리도 일관된다.

</details>
<details> <summary><strong>3. 왜 CustomUserDetailsService에서 비밀번호를 다시 encode하면 안 되나요?</strong></summary>
<strong>질문</strong>: new CustomUserDetail(email, passwordEncoder.encode(member.getPassword()))가 왜 문제인가?

<strong>답변</strong>:

DB에는 이미 BCryptPasswordEncoder로 암호화된 비밀번호가 저장돼 있다.

로그인 시에는 사용자가 보낸 평문 비밀번호와 DB의 암호화된 비밀번호를 passwordEncoder.matches(raw, encoded)로 비교해야 한다.

loadUserByUsername에서 다시 encode()를 호출하면, “이미 암호화된 비밀번호”를 또 암호화하는 꼴이라, 항상 매치에 실패하고 인증이 안 된다.

<strong>핵심</strong>:

encode()는 “회원가입/비밀번호 변경 시 DB에 넣기 전에 한 번”만,

로그인 시에는 matches()만, loadUserByUsername은 “DB에 있던 암호화된 값 그대로”를 반환해야 한다.

</details>
<details> <summary><strong>4. JwtAuthenticationFilter에서 permitAll 경로도 필터를 거치는 게 문제되지 않나요?</strong></summary>
<strong>질문</strong>: /member/sign-up처럼 permitAll인 요청도 JwtAuthenticationFilter를 타는데, 토큰이 없어서 예외 나지 않나?

<strong>답변</strong>:

보안 필터는 authorizeHttpRequests 보다 먼저 실행되기 때문에, permitAll 여부와 상관없이 모두 Jwt 필터는 거친다.

구현에서 “토큰 추출/검증 실패는 캐치 후 로그만 남기고, 인증 컨텍스트를 건드리지 않은 채 다음 필터로 넘긴다”로 설계했기 때문에, 토큰이 없어도 401이 아니라 정상 흐름으로 넘어간다.

최종 접근 허용 여부는 authorizeHttpRequests에서 permitAll 설정에 따라 결정되므로, 회원가입 등 공개 API는 인증 없이도 접근된다.

<strong>핵심</strong>:

Jwt 필터는 “있으면 검증해 인증을 세팅하는 역할”일 뿐이고,

“없으면 그냥 통과시키되, 접근 제어는 authorize 단계에서 한다”는 책임 분리가 중요하다.

</details>
<details> <summary><strong>5. 커스텀 LoginFilter에서 AuthenticationManager를 직접 주입해야 하는 이유는?</strong></summary>
<strong>질문</strong>: UsernamePasswordAuthenticationFilter를 상속했는데, 왜 setAuthenticationManager(...)를 직접 호출해야 하나?

<strong>답변</strong>:

스프링은 우리가 만든 LoginFilter를 빈으로 생성한 뒤, 초기화 과정에서 부모 필터(UsernamePasswordAuthenticationFilter.afterPropertiesSet)가 getAuthenticationManager()가 null인지 검사한다.

기본 폼 로그인 설정을 쓰면 스프링이 내부에서 필터와 AuthenticationManager를 자동으로 연결해주지만, 커스텀 필터를 직접 @Bean으로 등록했으므로 이 연결을 우리가 명시적으로 해줘야 한다.

생성자에서 받은 AuthenticationManager를 setAuthenticationManager(...)로 부모 필터에 세팅하면, 초기화 검사를 통과하고 인증 플로우도 올바르게 작동한다.

<strong>핵심</strong>:

“내가 만든 필터 + 내가 만든 SecurityFilterChain” 조합에선 배선(wiring) 책임이 개발자에게 있다.

부모 타입의 계약(authenticationManager must be specified)을 만족시키기 위해 수동으로 주입해주는 것.

</details>
<details> <summary><strong>6. LoginRequestDto에 Bean Validation 어노테이션이 있는데, 필터에서만 쓸 때 의미가 있나요?</strong></summary>
<strong>질문</strong>: @NotBlank, @Email을 DTO에 붙였지만 컨트롤러에서 @Valid를 안 쓰면 무슨 의미가 있나?

<strong>답변</strong>:

현재 구조는 필터에서 ObjectMapper로 DTO를 직접 만들기 때문에, 스프링 MVC의 자동 검증(@Valid)는 동작하지 않는다.

이 경우 어노테이션은 “검증 규칙에 대한 문서” 역할 정도만 하고, 실제 검증은 StringUtils.hasText(...) 등 수동 로직이 담당한다.

필요하다면 javax/jakarta Validator를 주입해서 validator.validate(dto)를 호출하는 방식으로 필터 안에서 Bean Validation을 직접 트리거할 수 있고, 그때 어노테이션이 실제 검증에도 사용된다.

<strong>핵심</strong>:

컨트롤러 바인딩을 안 타는 DTO는 @Valid가 자동으로 적용되지 않는다.

필터에서만 쓸 DTO라면, (1) 문서용 + 수동 검증으로 둘지, (2) Validator를 주입해 어노테이션 기반 검증까지 사용할지 선택의 문제다.

</details>
<details> <summary><strong>7. Stateless JWT API에서 CSRF를 disable한 이유는?</strong></summary>
<strong>질문</strong>: .csrf(AbstractHttpConfigurer::disable)가 보안 경고(Sonar)에 잡히는데, 왜 꺼도 된다고 판단했는가?

<strong>답변</strong>:

CSRF 공격은 브라우저가 자동으로 붙여주는 세션 쿠키를 악용하는 공격인데, 우리 API는 SessionCreationPolicy.STATELESS + Authorization: Bearer <token> 헤더 기반 인증이라 세션/쿠키를 사용하지 않는다.

브라우저가 임의의 외부 요청에 JWT 헤더를 자동으로 추가할 수 없기 때문에, 전형적인 CSRF 시나리오가 성립하지 않는다.

따라서 Stateless JWT 기반 REST API에서 CSRF를 비활성화하는 것은 Spring Security 측에서도 일반적인 설정이며, 대신 토큰 발급/검증, CORS 등을 적절히 관리하는 쪽이 중요하다.

<strong>핵심</strong>:

“쿠키 기반 세션 인증이 아닌 경우에는 CSRF의 공격 벡터가 없다”는 것을 이해하고 근거 있게 disable한 것.

Sonar 경고는 “무조건 위험”이 아니라 “의도를 설명해라” 수준의 Hotspot이므로, 설계 근거를 남기면 된다.

</details>