[서두]
- 오늘은 프로젝트 구조를 잡아감에 있어서 크게 고민해본적이 없었던 멀티 모듈과 다른 대안들에 대해서 알아보았고
그걸 정리해보려고한다.
[내용]
- 헥사고날 아키텍처 한줄 정의
도메인/유스케이스 같은 코어 로직을 중심에 두고, 웹, DB, 메시지큐, 외부 결제 등은 바깥쪽 “어댑터”로 격리하는 구조.
코어는 인터페이스(포트)만 알고, 구현(어댑터)은 코어를 모른 채 의존성이 안쪽 방향으로만 향하게 만드는 것이 핵심이다.
이렇게 하면 DB를 RDB → NoSQL로 바꾸거나, REST → gRPC로 바꿀 때 코어 비즈니스 로직 수정이 최소화된다.

​. 멀티모듈을 사용하는 이유 (해결하려는 문제)
단일 모듈(Monolithic Module) 프로젝트가 커지면 다음과 같은 고질적인 문제들이 발생합니다.
스파게티 코드와 의존성 오염: 모든 코드가 한곳에 섞여 있어, A 기능을 고쳤는데 전혀 상관없는 B 기능이 깨지는 현상이 발생합니다.
빌드 시간의 지옥: 코드 한 줄만 수정해도 프로젝트 전체를 다시 빌드해야 하므로 생산성이 급격히 떨어집니다.
코드 재사용의 어려움: '주문' 로직을 웹 서비스와 배치 서비스 모두에서 사용하고 싶을 때, 단일 모듈에서는 코드를 복사하거나 불필요한 설정까지 통째로 가져와야 합니다.

멀티모듈의 핵심 이점
관심사의 분리 (Separation of Concerns):
Domain 모듈(비즈니스 로직), API 모듈, Batch 모듈, Common 모듈 등으로 나누어 각 역할에만 집중하게 합니다.
의존성 제어:
API 모듈은 DB 설정이 필요할 수 있지만, 유틸리티 모듈은 DB 의존성이 필요 없을 수 있습니다. 각 모듈에 필요한 라이브러리만 최소한으로 가져다 쓸 수 있습니다.
빌드 속도 최적화:
변경이 발생한 모듈과 그에 의존하는 모듈만 다시 빌드하면 되므로(Incremental Build), 전체 빌드 시간을 단축할 수 있습니다.
유연한 확장:
나중에 특정 모듈만 떼어내어 **마이크로서비스(MSA)**로 전환하기 매우 유리합니다.

멀티모듈 트레이드 오프
설계 복잡도	모듈 간의 의존성 그래프를 설계하는 것이 까다롭습니다. 순환 참조(Circular Dependency)를 피해야 합니다.
설정 관리	build.gradle이나 pom.xml 설정이 복잡해집니다. 공통 설정을 관리하는 추가적인 노력이 필요합니다.
러닝 커브	팀원 모두가 모듈화의 원칙을 이해해야 합니다. 그렇지 않으면 다시 Common 모듈에 모든 코드가 몰리는 '쓰레기통 모듈' 현상이 발생합니다.

단일 모듈 vs 멀티 모듈: 선택을 위한 최종 가이드
A. 이런 상황이라면 '단일 모듈'로 시작하세요
1인 개발 혹은 2~3인 소규모 팀: 모듈 간 의존성 설정(Gradle)에 쏟는 시간보다 비즈니스 로직(결제 검증 등) 구현이 급할 때.
빠른 프로토타이핑: 재고 차감 로직이나 결제 상태 머신(CREATED -> PENDING -> PAID)을 한눈에 보며 수정하고 싶을 때.
대안: com.market.order, com.market.auth, com.market.product 처럼 패키지로만 분리하고 시작하세요.

B. 이런 상황이라면 '도메인 기반 멀티 모듈'로 시작하세요
인증 로직의 재사용성: 명세서의 Access/Refresh Token 및 Redis 로그아웃 로직을 다른 서비스(예: 관리자 앱, 파트너 앱)에서도 똑같이 써야 할 때. (auth-module 분리)
트래픽 격리: 상품 조회는 트래픽이 많고, 주문/결제는 트래픽은 적지만 리소스(DB 트랜잭션 등)를 많이 씁니다. 나중에 이 둘을 별도 서버로 배포할 계획이 확실할 때.
빌드 격리: 상품 정보를 수정했는데 결제 모듈까지 전체 테스트를 돌리는 것이 낭비라고 느껴질 만큼 코드가 비대해질 것으로 예상될 때.
