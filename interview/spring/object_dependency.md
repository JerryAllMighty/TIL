DAO & 드라이버
<details>
<summary>관심사의 분리(Separation of Concerns)를 이해하고 있는가?</summary>
<div markdown="1">
 하나의 객체가 너무 많은 책임을 갖지 않도록 서로 다른 이유로 변경되는 코드들을 분리하는 것입니다.
</div>
</details>


<details>
<summary>팩토리 메서드 패턴은 무엇인가?</summary>
<div markdown="1">
팩토리 메서드 패턴은 객체 생성 코드를 별도의 팩토리 메서드로 분리해서, 어떤 구체 클래스를 생성할지에 대한 결정을 서브클래스나 별도 팩토리에 위임하는 생성 패턴이다.
클라이언트는 생성자 대신 공통 팩토리 메서드를 호출하므로, 구체 타입에 대한 의존성이 줄어들고 새로운 제품 타입을 추가해도 클라이언트 코드를 최소 변경 또는 무변경으로 확장할 수 있다.
</div>
</details>

<details>
<summary>객체의 다형성이란 무엇인가?</summary>
<div markdown="1">
객체의 다형성은 서로 다른 클래스의 객체들이 같은 메시지(메서드 호출)에 대해 각자 다른 방식으로 응답할 수 있는 능력을 말한다.

주로 상속과 인터페이스를 통해, 상위 타입(인터페이스/추상 클래스)으로 여러 하위 타입을 한꺼번에 다루면서, 실제 런타임 타입에 따라 오버라이딩된 메서드가 호출되도록 함으로써 유연하고 재사용 가능한 코드를 작성할 수 있다
</div>
</details>

<details>
<summary>객체지향 설계 원칙이란 무엇인가?</summary>
객체지향 설계 원칙은 변경에 유연하고 재사용성과 유지보수성이 높은 소프트웨어를 만들기 위해 제안된 일련의 가이드라인으로, 대표적으로 SOLID 원칙이 널리 사용된다.

SOLID는 단일 책임 원칙, 개방-폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존 역전 원칙의 약자로, 각 원칙은 클래스의 책임 분리, 확장 용이성, 안정적인 상속 관계, 인터페이스 최소화, 추상화에 대한 의존 등을 통해 결합도를 낮추고 응집도를 높이는 것을 목표로 한다.
<div markdown="1">
</div>
</details>


제어의 역전 (IoC)
<details>
<summary>팩토리란 무엇인가?</summary>
팩토리는 객체 생성 로직을 캡슐화하여, 클라이언트가 구체적인 생성 과정이나 클래스 이름을 알지 못해도 요청만으로 적절한 객체 인스턴스를 돌려주는 역할을 하는 구성 요소이다.

이를 통해 객체 생성 책임을 한 곳으로 모으고, 생성 정책을 변경하거나 새로운 타입을 도입할 때 클라이언트 코드를 최소한으로 변경하면서 시스템을 확장할 수 있다.


<div markdown="1">
</div>
</details>

<details>
<summary>빈과 빈 팩토리는 무엇인가?</summary>
<div markdown="1">
스프링에서 빈(Bean)은 스프링 IoC 컨테이너가 생성·관리·의존성 주입까지 책임지는 관리 대상 객체를 의미한다.

빈 팩토리(BeanFactory)는 이러한 빈들을 생성하고 의존성을 주입하며 생명주기를 관리하는 최소한의 기능을 가진 스프링 IoC 컨테이너의 기본 인터페이스로, 설정 메타데이터를 읽어 필요한 시점에 빈을 생성·제공한다
</div>
</details>

<details>
<summary>애플리케이션 컨텍스트란 무엇인가?</summary>
<div markdown="1">
애플리케이션 컨텍스트(ApplicationContext)는 BeanFactory를 확장한 스프링의 고급 IoC 컨테이너로, 빈 관리 기능에 더해 AOP 연동, 메시지 소스, 이벤트 발행 등 엔터프라이즈 애플리케이션에 필요한 여러 부가 기능을 제공한다.

일반적인 스프링 애플리케이션에서는 BeanFactory 대신 ApplicationContext를 사용하며, 애플리케이션 전역에서 사용할 빈들을 미리 로딩하고 의존성을 주입하여 런타임에 손쉽게 조회·사용할 수 있게 한다.


</div>
</details>

<details>
<summary>애플리케이션 컨텍스트의 동작원리에 대해 설명해보라</summary>
<div markdown="1">
애플리케이션 컨텍스트는 먼저 설정 정보(자바 설정 클래스, XML, 애노테이션 스캔 등)를 읽어 빈 정의 메타데이터를 구성하고, 이 정보를 바탕으로 빈들의 생성 방식과 의존 관계를 분석한다.

컨텍스트 초기화 시 이 메타데이터에 따라 필요한 빈을 인스턴스화하고, 의존성 주입과 라이프사이클 콜백, 후처리기를 적용한 뒤 컨테이너 내부에 캐싱하여, 이후에는 getBean이나 자동 주입을 통해 동일한 빈 인스턴스를 제공함으로써 애플리케이션 전역의 객체 그래프를 일관되게 관리한다.
</div>
</details>

<details>
<summary>동일성과 동등성은 어떻게 다른가?</summary>
<div markdown="1">
동일성(identity)은 두 참조가 메모리상에서 정확히 같은 객체 인스턴스를 가리키는가를 의미하며, 자바에서는 == 연산자가 이를 비교한다.

동등성(equality)은 두 객체의 내용(상태나 값)이 논리적으로 같은가를 의미하며, 자바에서는 equals 메서드로 정의·비교하며, 서로 다른 인스턴스라도 같은 값으로 간주될 수 있다는 점에서 동일성과 구분된다.


</div>
</details>

<details>
<summary>싱글톤 패턴이란?</summary>
<div markdown="1">
싱글톤 패턴은 어떤 클래스의 인스턴스를 애플리케이션 전체에서 오직 하나만 존재하도록 보장하고, 그 전역 인스턴스에 접근할 수 있는 공용 수단을 제공하는 생성 패턴이다.
​
이를 위해 생성자를 외부에서 호출하지 못하게 제한하고(예: private 생성자), 클래스 내부에 유일한 인스턴스를 저장한 뒤 정적 메서드 등을 통해 동일한 인스턴스를 반복 제공하여, 공유 자원 관리나 전역 설정 같은 역할을 수행하게 한다
</div>
</details>

<details>
<summary>객체의 생성과 생명주기 제어권을 본인이 아닌 외부(컨테이너)에 위임하는 이유는?</summary>
<div markdown="1">
객체 간의 결합도를 낮추고, 객체가 본연의 비즈니스 로직에만 집중하게 하기 위해서입니다.
객체가 스스로 사용할 구현 클래스를 결정하고 생성하면 강한 결합이 생깁니다. 
제어권을 컨테이너(외부)에 넘기면, 객체는 어떤 구체적인 객체가 주입될지 몰라도 자신의 역할만 수행하면 되므로 유연한 확장이 가능해집니다.
</div>
</details>


의존관계 주입 (DI)
<details>
<summary>DI의 세 가지 조건(인터페이스 의존, 런타임 결정, 제 3자의 개입)을 설명할 수 있는가?</summary>
<div markdown="1">
1. 인터페이스 의존: 설계 시점에는 구체적인 클래스를 알지 못한 채 인터페이스에만 의존해야 합니다.
2. 런타임 결정: 실제 사용될 구체적인 객체는 애플리케이션이 실행되는 시점에 결정됩니다.
3. 제 3자의 개입: 두 객체 사이의 관계를 맺어주는 외부 존재(스프링 컨테이너/Assembler)가 반드시 필요합니다.
</div>
</details>

<details>
<summary>의존 관계 주입과 의존 관계 검색의 차이는 무엇인가?</summary>
<div markdown="1">
1. 인터페이스 의존: 설계 시점에는 구체적인 클래스를 알지 못한 채 인터페이스에만 의존해야 합니다.
2. 런타임 결정: 실제 사용될 구체적인 객체는 애플리케이션이 실행되는 시점에 결정됩니다.
3. 제 3자의 개입: 두 객체 사이의 관계를 맺어주는 외부 존재(스프링 컨테이너/Assembler)가 반드시 필요합니다.
</div>
</details>


싱글톤 레지스트리
<details>
<summary>스프링 빈이 기본적으로 싱글톤인 이유와, 멀티쓰레드 환경에서의 주의점(상태 유지 X)은?</summary>
<div markdown="1">
서버 환경은 수많은 요청이 동시에 들어오는데, 요청마다 객체를 생성하면 메모리 부하와 가비지 컬렉션(GC) 부담이 너무 커지기 때문
여러 쓰레드가 공유하므로 상태 정보(인스턴스 변수)를 가지지 않는 무상태(Stateless) 방식으로 설계해야 합니다. 즉, 로컬 변수나 파라미터를 사용해야 데이터가 꼬이지 않습니다.
</div>
</details>

<details>
<summary>스프링 빈의 스코프에 대해서 설명하라?</summary>
<div markdown="1">
스프링 빈의 스코프는 빈이 생성되고 존재하며 소멸하는 생명주기 범위를 정의하며, 기본값은 싱글톤이다
</div>
</details>


전략 패턴 (Strategy Pattern)
<details>
<summary>변하지 않는 맥락(Context) 속에서 변하는 로직(Strategy)을 분리해 보았는가?</summary>
<div markdown="1">
기능을 구현한 알고리즘(전략)을 인터페이스로 캡슐화하고, 이를 상황에 따라 교체해서 사용하는 패턴
</div>
</details>


개방 폐쇄 원칙 (OCP)
<details>
<summary>기능 확장에는 열려 있고 변경에는 닫혀 있다는 말이 코드 수준에서 어떻게 구현되는가?</summary>
<div markdown="1">
인터페이스와 다형성을 통해 구현됩니다.
새로운 DB를 추가하고 싶을 때(확장에는 열림), 기존의 UserDao 소스 코드를 단 한 줄도 수정하지 않고(변경에는 닫힘) 새로운 드라이버 클래스를 만들어 인터페이스를 구현하기만 하면 되는 상태를 의미합니다.
</div>
</details>


<details>
<summary>컨테이너/ IoC 컨테이너에 대해서 설명하라</summary>
<div markdown="1">
컨테이너란 소프트웨어에서 컨테이너는 객체의 생명주기(Life Cycle)를 관리하고 필요한 서비스를 제공하는 공간을 의미합니다.
우리가 흔히 쓰는 서블릿 컨테이너(Tomcat 등)가 서블릿의 생성과 소멸을 관리하듯, 스프링 컨테이너는 우리가 만든 '객체(Bean)'들을 관리합니다.

스프링에서 객체(Bean)를 생성하고, 서로 연결(의존성 주입)해주며, 소멸까지 책임지는 주체입니다.
왜 사용하는가? (Product Engineer의 관점)
유연한 확장: 객체 간의 결합도가 낮아지므로, 부품(객체)을 교체하기가 매우 쉽습니다. (예: JDBC에서 JPA로 DB 접근 로직을 바꿀 때 코드 수정 최소화)
테스트 용이성: 가짜 객체(Mock)를 주입하기 쉬워져서 서비스의 안정성을 검증하기 좋습니다.
비즈니스 집중: 개발자는 객체 생성 같은 인프라적인 고민 대신, 실제 제품의 기능(Business Logic) 구현에만 에너지를 쓸 수 있습니다.
</div>
</details>
	
	
	




	



