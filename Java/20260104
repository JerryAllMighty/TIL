[서두]
- 스택이랑 힙에 관하여 정리했다.

[내용]
정의
스택
각 스레드마다 하나씩 있고, 메서드 호출 시 생기는 “스택 프레임” 안에 매개변수, 지역 변수, 리턴 주소를 저장하는 구역.

메서드가 끝나면 해당 프레임이 통째로 사라져서, 수명 관리가 단순하고 접근이 빠름.

힙
new로 만든 모든 객체 인스턴스가 올라가는 공용 구역이고, 여러 스레드가 같이 본다.
클래스, 인스턴스 대부분이 힙에 올라간다.

언제까지 살아있을지는 가비지 컬렉터가 참조 여부를 보고 정리하며, 스택보다 크지만 접근·관리 비용이 더 큼.

무슨 문제를 해결하려 나온 개념일까?
지역 변수처럼 “짧게 쓰고 금방 버릴 것”과, 여러 메서드/스레드에서 “오래 같이 써야 할 것”의 수명 관리 방식이 달라야 한다는 문제.
짧고 규칙적인 건 스택(LIFO)로 자동 관리 → 속도·안정성.
크기/수명이 유동적인 건 힙+GC로 관리 → 개발자가 직접 free 안 해도 됨.

“언제” 이 차이가 실제로 중요해질까?
상황 예시
재귀 깊이 많을 때: 스택 프레임이 계속 쌓여서 StackOverflowError 가능.
객체 많이 만드는 서비스: 힙 사용량·GC pause가 성능과 직결.
멀티스레드: 스택은 스레드마다 분리, 힙은 공유라서 동시성 제어 필요.

대안은 없었나?
“모든 걸 힙에 둘 수 없나?” → 그럼 호출/지역 상태까지 전부 GC 대상이 되어 오버헤드↑, 단순한 수명 관리까지 비효율.

“모든 걸 스택에 둘 수 없나?” → 수명·크기가 고정되지 않아서 현실적으로 불가능.

한계
스택: 크기 제한, 깊은 재귀·큰 지역 배열 등에서 터짐.

힙: GC가 있으므로 “레퍼런스만 남아있는 논리적 메모리 누수”가 생길 수 있고, GC 튜닝 이슈가 생김.

전형적인 실수
힙을 과도하게 쓰는 패턴: 전역 캐시/컬렉션에 객체를 쌓기만 하고 제거 안 해서 OutOfMemoryError.

스택 기반 실수: 재귀로 간단히 풀려서 넣었는데, 입력 크기 커지면 StackOverflowError.

수명 오해: “지역 변수니까 메서드 끝나면 객체도 사라지겠지?” → 참조가 다른 곳(필드, 컬렉션)에 남아 있으면 힙 객체는 계속 살아 있음.

C / Kotlin과 비교
C:
스택: 함수의 지역 변수, 매개변수 저장은 비슷하지만, 구조체를 통째로 스택에 두는 등 더 자유롭고, 프레임 수명은 함수 호출/리턴에 직접 대응.

힙: malloc/free로 직접 관리해야 해서, 해제 누락·이중 해제·댕글링 포인터 같은 버그가 빈번.

Kotlin(JVM 기준):
같은 JVM 위라서 자바와 스택/힙 모델은 본질적으로 동일.

다만 언어 수준에서 널 안정성, 불변 컬렉션, 코루틴 스코프 등으로 “힙에 있는 객체의 수명·소유”를 더 안전하게 표현하게 해 줌.
