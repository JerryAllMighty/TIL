[서두]
- 오늘은 volatile 키워드 관련 정리한 글이 좋아서 공유하려한다.

[본론]
- 일단, volatile이 어떤 키워드일까?
volatile 키워드는 각 스레드가 캐시(레지스터/CPU 캐시)에 자기 복사본을 들고 있지 않고, 항상 메인 메모리에서 값을 읽고 쓰도록 해서 “가시성 문제”를 해결한다.

기본적으로 스레드마다 성능 최적화를 이유로 캐시를 기본으로 하고 있다.
원본과 다른 것을 따로 들고있다는 뜻이기 때문에 가시성이 떨어진다.
즉각적으로 반영이 안 될 수 있다는 뜻이다.

그래서 이 때 volatile을 써서 그 캐시에 쓰지 말라고 하는거다. 메모리에서 직접 읽어가라는 뜻이다.
그래서 메인 메모리에서 직접 읽어가니 느리다.
volatile 키워드가 없으면 최적화해서 캐시 쓸 수 있는 것이다.

또 volatile 변수에 대한 읽기/쓰기 앞뒤로 메모리 배리어를 두어, 해당 변수 관련한 명령어 재정렬을 막고 happens-before 관계를 보장한다

volatile은 왜 명시적으로 써야할까? 기본 값이 아니고?
모든 공유 변수에 저 보장을 기본으로 걸면,
매 접근마다 메인 메모리를 강제하게 되어 캐시 활용이 떨어지고
CPU·컴파일러 최적화(명령어 재정렬 등)를 크게 제한해서 성능이 떨어진다.

실제로 멀티스레드 프로그램에서도 “가시성 보장이 꼭 필요한 플래그/상태 변수”는 일부이기 때문에, 그때만 volatile을 명시해서 의도와 비용을 분명히 하는 디자인을 택한 것이다

언제 굳이 명시해서 쓰는가
대표적으로 “loop를 빠져나가게 만드는 종료 플래그”
double-checked locking에서 인스턴스 초기화 완료 여부 플래그
처럼 “값이 바뀌면 다른 스레드가 바로 알아야 하는” 변수에 쓴다.

반대로 ++, -- 같은 복합 연산이 있는 카운터나 통계 값에는 volatile만으로는 원자성이 보장되지 않으므로, AtomicInteger나 synchronized/락을 써야 하고 그래서 더더욱 모든 변수에 기본 적용하기엔 부적절하다.

왜 atomic이라는 개념이 필요했나?
멀티스레드 환경에서 count++ 같은 연산은 실제로는
“읽기 → 더하기 → 쓰기”라는 여러 단계의 기계어로 나뉜다.
여러 스레드가 동시에 count++를 실행하면, 중간에 값이 덮어써져서 증가가 누락되는 문제가 생긴다. 이런 연산을 하나의 끊을 수 없는 단위(원자 연산)로 보장해 달라는 요구에서 atomic이라는 개념이 나온 것이다.

전통적으로는 이런 문제를 synchronized(모니터 락) 같은 블로킹 락으로 해결했지만, 락은 진입/해제 시마다 문맥 전환, 캐시 flush 등 비용이 크고, 경쟁이 심하면 병목이 되었다. 그래서 “락 없이( non-blocking )도 단일 변수 정도는 안전하게 업데이트하고 싶다”는 요구가 강하게 생겼다

Java Atomic 클래스는 왜 등장했나
Java 5에서 JMM 재정의 + 동시성 유틸리티(java.util.concurrent)가 도입되면서,
synchronized만으로는 성능/표현력이 부족하다는 인식이 생겼고, 그 대안 중 하나로 CAS(Compare-And-Swap) 기반의 Atomic 클래스들이 추가되었다.

AtomicInteger, AtomicLong, AtomicBoolean, AtomicReference 등은
“이 변수에 대한 읽기-수정-쓰기 연산을 원자적으로”
“락 없이(CAS로)” 수행할 수 있게 설계되었다.

내부적으로는 CPU가 제공하는 CAS 명령어(또는 그에 상응하는 primitive)를 JNI/native 코드로 호출해서 구현하고, 실패하면 다시 재시도하는 식으로 동작한다.

즉, 동시성 문제를 해결하는 세 가지 축이 생긴 셈이다.
가시성만 보장: volatile
원자성 + 가시성, 블로킹 락: synchronized / ReentrantLock
원자성 + 가시성, non‑blocking: Atomic 계열 (CAS 기반)

요약적으로 말하면
CPU·컴파일러 최적화 + 멀티코어 환경에서, 단순 연산조차도 스레드 경쟁 시 깨지는 문제가 커졌다.

모든 곳에 락을 걸면 성능과 확장성이 떨어지기 때문에, “단일 변수 수준에서 락 없이 원자성을 보장하는 도구”가 필요했고, 그 요구를 반영한 결과가 오늘날 말하는 atomic 연산/Atomic 클래스다.
