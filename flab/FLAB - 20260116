[서두]
- 오늘은 CAS 알고리즘에 관해 알아보았다


[내용]
기본 개념
CAS(Compare-And-Swap / Compare-And-Set)는 공유 변수 하나를 “조건부로” 바꾸는 하드웨어 수준의 원자 연산이다. 락을 잡지 않고도 여러 스레드가 동시에 안전하게 값을 갱신하게 만드는 게 핵심 목적이다.

기본 아이디어
CAS는 세 개의 값을 사용한다.

M: 바꾸고 싶은 메모리 위치(공유 변수)
A: 기대하는 옛 값(expected)
B: 새로 쓰고 싶은 값(new)

동작은 매우 단순하다.
메모리 M의 현재 값을 읽어서 A와 비교.
만약 M == A이면, M에 B를 쓰고 “성공(true)”를 반환.
M != A이면, 아무 것도 쓰지 않고 “실패(false)”를 반환.
이 전체 비교+쓰기 과정이 원자적(atomic) 으로 한 번에 수행되기 때문에, 중간에 다른 스레드가 끼어들 수 없다.

CAS로 공유 값 갱신하는 패턴 (루프)
가장 전형적인 패턴은 “CAS 루프”다.

현재 값 읽기 old = M
old를 기반으로 new 계산
CAS(M, old, new)를 시도
성공하면 끝
실패하면 “누가 그 사이에 M을 바꿨구나” → 다시 1번부터 반복
이 패턴으로 락 없이(lock-free) 카운터 증가, 스택/큐 push/pop 같은 연산을 구현할 수 있다.

왜 쓰는가? (장점)
락 없이 동시성 제어
synchronized, mutex 같은 락은 스레드를 블로킹시키고 컨텍스트 스위칭 오버헤드를 만든다.
CAS는 실패해도 스레드는 블록되지 않고, 그냥 다시 시도하면 되므로 lock-free / non-blocking 알고리즘을 만들 수 있다.

높은 경쟁 환경에서 유리
읽기 많은 환경, 짧은 갱신 로직에서는 단순 락보다 CAS가 더 높은 처리량을 내는 경우가 많다.
자바 등에서 Atomic 클래스의 기반
Java AtomicInteger, AtomicReference의 compareAndSet()이 바로 CAS를 감싼 API다.

단점·주의점
실패하면 루프를 돌며 바쁘게 재시도(spin)
경쟁이 심하면 CAS가 계속 실패해서 CPU를 많이 쓸 수 있다.
한 번에 “하나의 메모리 위치”만 안전하게 갱신
여러 필드를 한꺼번에 원자적으로 바꿔야 하면 CAS 하나로는 부족하고, 더 복잡한 알고리즘이나 여전히 락이 필요하다.

ABA 문제
스레드가 값 A를 읽은 후 잠깐 사이에 다른 스레드가 A→B→A로 바꿨다면, 겉으로 보면 다시 A라서 CAS가 성공해 버린다. 실제로는 중간에 상태가 변했는데도 감지 못하는 현상을 ABA 문제라고 부른다.

해결책으로는 값과 함께 버전(stamp)을 두는 AtomicStampedReference 같은 방식이 있다.

어디에 쓰이는가 (사용 예)
락 프리 스택/큐/링크드 리스트
top/head 포인터를 CAS로 바꾸는 방식으로 push/pop 구현.

원자 카운터/통계 값
요청 수, 시퀀스 번호, 참조 카운트 등 단일 숫자 업데이트.

JVM/런타임 내부
Java의 GC, 스레드 스케줄링, 다양한 런타임 자료구조에서 CAS 기반 원자 연산을 사용.

결론
정리하면, CAS 알고리즘은 “기대한 값일 때만 바꾼다”는 아주 단순한 원자 연산으로 락 없이도 여러 스레드가 공유 데이터를 안전하게 업데이트하도록 만들기 위한 기반 기법이고, 장점은 lock-free 성능·진행 보장, 단점은 스핀/ABA·복잡도 증가라고 보면 된다
