[서두]
- String 클래스를 공부하다, 불변 객체 > String Builder, Buffer 공부하다, 결국 더하기 연산 최적화까지 오게 되었다.
- 좋은 내용이라 정리해두려한다.

[내용]
-
-컴파일러 최적화 (JDK 5+ invokedynamic)
java
// 컴파일 후 → StringBuilder로 자동 변환
String s = "a" + "b" + 123 + "c";  
// bytecode: invokedynamic #makeConcatWithConstants (StringBuilder 내부 사용)
리터럴 위주: 컴파일 타임에 StringBuilder 생성 (성능 최상)
변수 혼합: 런타임에 StringBuilder (여전히 빠름)

루프 최적화: StringBuilder 필수
java
// ❌ O(n²) - 매번 새 String 생성
String result = "";
for (int i = 0; i < 1000; i++) {
    result += i;  // 1000개 String 객체 생성!
}

// ✅ O(n) - 버퍼 재사용
StringBuilder sb = new StringBuilder(1024);  // 초기 용량 지정
for (int i = 0; i < 1000; i++) {
    sb.append(i);
}
String result = sb.toString();
현대 Java 최적화 (JDK 9+ StringConcatFactory)
text
+ 연산자 → invokedynamic → StringConcatFactory
- 최적 StringBuilder 생성
- 불필요한 toString() 제거
- "a" + 123 → "a123" 직접 생성
관련 JVM 옵션
인라인/최적화 관련
text
-XX:+AggressiveOpts # 공격적 최적화 활성화
-XX:MaxInlineSize=32 # 인라인 크기 증가 (+ 연산자 인라인 ↑)
-XX:+TieredCompilation # C1/C2 컴파일러 혼합 (String 최적화 ↑)
-XX:CompileThreshold=1000 # JIT 컴파일 임계값 조정

StringBuilder 메모리 관련
text
-XX:NewRatio=2 # Young:Old 비율 (StringBuilder 단명 객체 ↑)
-XX:SurvivorRatio=8 # Eden:Survivor 비율
-Xmx4g -Xms4g # Heap 크기 고정 (GC 최소화)

성능 측정 추천
# JIT 최적화 후 측정
java -XX:+PrintCompilation -XX:+TieredCompilation YourApp
# StringBuilder 인라인 확인
javap -c YourClass | grep invokedynamic
실무 권장
text
간단 2~3개: "a" + b + "c" (컴파일러 최적화)
루프/대량: StringBuilder(용량 지정)
JDK 15+: String::formatted("Hi %s", name) 신문법
성능 차이: 1000개 루프에서 +는 2초 → StringBuilder 10ms (200배 차이!)

결론
컴파일러: "+" → invokedynamic 바이트코드 생성
JVM (JDK 9+): invokedynamic → StringConcatFactory 호출 → 최적 StringBuilder
1. 컴파일 타임: "a" + name + "!" → invokedynamic #makeConcatWithConstants
2. 런타임 첫 호출: StringConcatFactory가 "recipe" 분석 → 최적 메서드 생성
3. 이후 호출: 캐싱된 메서드 재사용 (StringBuilder 내부적으로 동작)
