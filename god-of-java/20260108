[서두]
- Integer 캐싱에 대해서 알아보았다
[본론]
- 정의
인티저 캐싱은 자바가 자주 쓰이는 작은 정수 값에 대해 Integer 객체를 미리 만들어 두고 재사용하는 최적화 기법

자바는 내부에 IntegerCache라는 캐시를 두고, 기본적으로 -128부터 127 사이의 Integer 객체를 미리 만들어 저장해 둔다.

Integer.valueOf(10)처럼 이 범위의 값을 요청하면, 새 객체를 만들지 않고 이 캐시에 있는 동일한 객체를 돌려준다.

그래서 Integer a = 127; Integer b = 127;일 때 a == b는 true가 되고, Integer a = 128; Integer b = 128;일 때는 캐시 범위 밖이라 보통 다른 객체라 a == b는 false가 된다.

이 최적화 덕분에 자주 쓰이는 작은 숫자들에 대해 객체 생성 비용과 메모리 사용을 줄이고
박싱된 정수 비교에서 ==를 잘못 쓰면 버그가 날 수 있는 이유를 만들어내기도 함.

구현은 어떻게 되어있을까
class Integer {
    private static class IntegerCache {
        static final int low  = -128;
        static final int high;        // 기본 127, 옵션으로 상향 가능
        static final Integer[] cache;

        static {
            int h = 127;
            // 시스템 프로퍼티로 high 조정 가능 (예: -Djava.lang.Integer.IntegerCache.high=...)
            String prop = VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
            if (prop != null) {
                try {
                    int parsed = Integer.parseInt(prop);
                    h = Math.max(parsed, 127);
                    h = Math.min(h, Integer.MAX_VALUE - (-low) - 1);
                } catch (NumberFormatException ignore) {}
            }
            high = h;

            int size = (high - low) + 1;
            cache = new Integer[size];
            int value = low;
            for (int i = 0; i < size; i++) {
                cache[i] = new Integer(value++);
            }
        }

        private IntegerCache() {}
    }

    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high) {
            return IntegerCache.cache[i - IntegerCache.low];
        }
        return new Integer(i);
    }
}
low = -128, high는 기본 127이고, JVM 옵션으로 127보다 크게 늘릴 수 있음.
예: -Djava.lang.Integer.IntegerCache.high=1000 또는 -XX:AutoBoxCacheMax=1000 같은 식으로 상한 조절 가능.

static 블록에서 low부터 high까지 모든 Integer 인스턴스를 한 번에 전부 생성해서 cache 배열에 채워 둠.

Integer.valueOf(int)가 호출되면

요청 값이 [low, high] 범위면 cache[index]에서 기존 객체를 리턴

범위 밖이면 new Integer(i)로 새 객체를 생성.
