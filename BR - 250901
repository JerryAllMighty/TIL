[서두]
오늘 단건 조회, 혹은 삭제싱에 Seq 를 활용하기보다는, 도메인 혹은 객체를 통으로 사용하라고 피드백을 받았다.
ex)
Phone이라는 도메인이 있다고 가정하다. 그리고 Phone을 단건 조회해서 가져온다고 가정하자.
AS-IS : AService.select(Phone.getSeq());
TO-BE : AService.select(Phone);

막상 개발할 때는, 해당 객체를 활용하여 select나 delete를 하는 것이 꼭 Key. 값이 Seq만은 아니니, 맞춰서서두]
오늘 단건 조회, 혹은 삭제싱에 Seq 를 활용하기보다는, 도메인 혹은 객체를 통으로 사용하라고 피드백을 받았다.
ex)
Phone이라는 도메인이 있다고 가정하다. 그리고 Phone을 단건 조회해서 가져온다고 가정하자.
AS-IS : AService.select(Phone.getSeq());
TO-BE : AService.select(Phone);

막상 개발할 때는, 해당 객체를 활용하여 select나 delete를 하는 것이 꼭 Key. 값이 Seq만은 아니니 그런가보다라고 생각하고 수정을 완료했는데,
집에 와서 회고를 하다보니 이러한 부분을 기존에 정의한 이론이나 개념이 있는지, 잘 정리된 베스트 프랙티스는 뭔지 알고 가야겠다고 생각했다.

[본론]
- 원시값 기반 접근 (Primitive Value)
> Identifier Parameter Style: ID/seq 같은 식별자를 넘기는 경우.
> 의미 전달력 부족 : 단순히 Seq 등만넘기면 도메인의 의미를 드러내지 못한다.
> 불필요한 객체생성을 피할 수 있다. 
> 확장성 부족 : 추후 조건이 늘어나면 파라미터가 늘어나기 시작한다.
> DB 중심 / 절차적 사고
 >> 강한 결합 : 특정 DB 스키마 컬럼(Seq) 에 직접 의존한다.
 >> 데이터베이스/테이블 레벨 추상화
 ex) userRepository.deleteById(10L);
 해석: "10번이라는 키 값을 가진 데이터를 지워라"
 DB 테이블 레코드를 직접 다루는 느낌이 강함.
 호출자가 도메인 모델과 협력한다기보다, DB의 구조(PK)에 의존하는 방식.



- 객체 도메인 기반 접근
> Domain Object Parameter Style: 도메인 객체 자체를 넘기는 경우
> 도메인의도를 파악하기 쉽다 : deleteByUser(User user) → “이 User를 기준으로 삭제한다”라는 의미가 명확.
> 불필요한 객체를 만들어야 하는 경우 오버헤드가 있음.
> 확장 용이 : 객체에 필드가 추가되어도 메서드 시그니처는 바뀌지 않음. (ex. User 객체에 email이 추가되면 그대로 활용 가능)
> 도메인/객체지향 사고 중심
  >> 객체지향적 캡슐화: 도메인 모델에 책임을 위임할 수 있음.
  >> 도메인 레벨 추상화
  >> 객체 지향 설계 원칙에 가깝다 : 
    >>> 캡슐화: 호출자는 내부 구현(PK, SQL 등)을 몰라도 됨.
    >>> 추상화 수준 유지: "DB 레코드를 지운다"보다 "사용자를 지운다"가 더 도메인에 가까움.
    >>> 협력의 관점: 객체들이 서로 메시지를 주고받으며 일한다는 모델을 따름.
    >>> 유연성: 나중에 삭제 로직이 "논리적 삭제(soft delete)"로 바뀌더라도, delete(user)라는 인터페이스는 그대로 유지할 수 있음.

[결론]
- DB 중심 /절차적 사고냐 아니면 도메인/객체지향적 사고냐에 따라서 취향 선택하면 되시겠다.
