DAO & 드라이버
<details>
<summary>관심사의 분리(Separation of Concerns)를 이해하고 있는가?</summary>
<div markdown="1">
 하나의 객체가 너무 많은 책임을 갖지 않도록 서로 다른 이유로 변경되는 코드들을 분리하는 것입니다.
</div>
</details>


제어의 역전 (IoC)
<details>
<summary>객체의 생성과 생명주기 제어권을 본인이 아닌 외부(컨테이너)에 위임하는 이유는?</summary>
<div markdown="1">
객체 간의 결합도를 낮추고, 객체가 본연의 비즈니스 로직에만 집중하게 하기 위해서입니다.
객체가 스스로 사용할 구현 클래스를 결정하고 생성하면 강한 결합이 생깁니다. 
제어권을 컨테이너(외부)에 넘기면, 객체는 어떤 구체적인 객체가 주입될지 몰라도 자신의 역할만 수행하면 되므로 유연한 확장이 가능해집니다.
</div>
</details>


의존관계 주입 (DI)
<details>
<summary>DI의 세 가지 조건(인터페이스 의존, 런타임 결정, 제 3자의 개입)을 설명할 수 있는가?</summary>
<div markdown="1">
1. 인터페이스 의존: 설계 시점에는 구체적인 클래스를 알지 못한 채 인터페이스에만 의존해야 합니다.
2. 런타임 결정: 실제 사용될 구체적인 객체는 애플리케이션이 실행되는 시점에 결정됩니다.
3. 제 3자의 개입: 두 객체 사이의 관계를 맺어주는 외부 존재(스프링 컨테이너/Assembler)가 반드시 필요합니다.
</div>
</details>


싱글톤 레지스트리
<details>
<summary>스프링 빈이 기본적으로 싱글톤인 이유와, 멀티쓰레드 환경에서의 주의점(상태 유지 X)은?</summary>
<div markdown="1">
서버 환경은 수많은 요청이 동시에 들어오는데, 요청마다 객체를 생성하면 메모리 부하와 가비지 컬렉션(GC) 부담이 너무 커지기 때문
여러 쓰레드가 공유하므로 상태 정보(인스턴스 변수)를 가지지 않는 무상태(Stateless) 방식으로 설계해야 합니다. 즉, 로컬 변수나 파라미터를 사용해야 데이터가 꼬이지 않습니다.
</div>
</details>


전략 패턴 (Strategy Pattern)
<details>
<summary>변하지 않는 맥락(Context) 속에서 변하는 로직(Strategy)을 분리해 보았는가?</summary>
<div markdown="1">
기능을 구현한 알고리즘(전략)을 인터페이스로 캡슐화하고, 이를 상황에 따라 교체해서 사용하는 패턴
</div>
</details>


개방 폐쇄 원칙 (OCP)
<details>
<summary>기능 확장에는 열려 있고 변경에는 닫혀 있다는 말이 코드 수준에서 어떻게 구현되는가?</summary>
<div markdown="1">
인터페이스와 다형성을 통해 구현됩니다.
새로운 DB를 추가하고 싶을 때(확장에는 열림), 기존의 UserDao 소스 코드를 단 한 줄도 수정하지 않고(변경에는 닫힘) 새로운 드라이버 클래스를 만들어 인터페이스를 구현하기만 하면 되는 상태를 의미합니다.
</div>
</details>

	
	
	




	



